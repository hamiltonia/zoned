#!/bin/bash
#
# vm-logs - Watch extension logs from VM
#
# Tails GNOME Shell logs from the VM over SSH,
# filtering for Zoned-related messages.
#
# Uses auto-detection to find running VM (no config file needed).
#
# Usage:
#   ./scripts/vm-logs        - Show only Zoned messages
#   ./scripts/vm-logs all    - Show all GNOME Shell logs
#

set -e

# Script location
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source the shared VM detection library
source "$SCRIPT_DIR/../lib/vm-detect.sh"

# Extension details
EXTENSION_UUID="zoned@hamiltonia.me"

# ============================================
#  MAIN
# ============================================

main() {
    # Detect running VM (quietly - just need the connection)
    local running_vms
    running_vms=$(vm_get_running)
    
    if [[ -z "$running_vms" ]]; then
        vm_print_error "No VMs are currently running"
        echo ""
        echo "Start a VM first, then run this command again."
        exit 1
    fi
    
    # Count running VMs
    local count
    count=$(echo "$running_vms" | wc -l)
    
    if [[ $count -eq 1 ]]; then
        VM_DOMAIN="$running_vms"
    else
        # Multiple VMs - prompt to select
        echo -e "${CYAN}Multiple VMs are running:${NC}"
        echo ""
        
        local vms=()
        local i=1
        while IFS= read -r vm; do
            [[ -z "$vm" ]] && continue
            local title=$(vm_get_title "$vm")
            echo "  $i) $vm - \"$title\""
            vms+=("$vm")
            ((i++))
        done <<< "$running_vms"
        
        echo ""
        read -p "Select VM [1-${#vms[@]}]: " selection
        
        if [[ ! "$selection" =~ ^[0-9]+$ ]] || [[ $selection -lt 1 ]] || [[ $selection -gt ${#vms[@]} ]]; then
            vm_print_error "Invalid selection"
            exit 1
        fi
        
        VM_DOMAIN="${vms[$((selection-1))]}"
    fi
    
    # Test SSH connection
    if ! ssh -o ConnectTimeout=5 -o BatchMode=yes "$VM_DOMAIN" "exit" 2>/dev/null; then
        vm_print_error "Cannot connect to VM: $VM_DOMAIN"
        echo ""
        echo "Run 'make vm-dev' first to set up SSH access."
        exit 1
    fi
    
    # Get VM details for display
    local vm_title=$(vm_get_title "$VM_DOMAIN")
    local vm_ip=$(vm_get_ip "$VM_DOMAIN")
    
    echo -e "${BLUE}════════════════════════════════════════════════════════════${NC}"
    echo -e "${BLUE}   Watching VM logs (Ctrl+C to stop)${NC}"
    echo -e "${BLUE}════════════════════════════════════════════════════════════${NC}"
    echo -e "${YELLOW}VM: $VM_DOMAIN${NC} - \"$vm_title\""
    echo -e "${YELLOW}IP: $vm_ip${NC}"
    echo -e "${BLUE}════════════════════════════════════════════════════════════${NC}"
    echo
    
    # Determine filter mode
    local filter_mode="${1:-zoned}"
    
    if [[ "$filter_mode" == "all" ]]; then
        echo -e "${BLUE}Showing ALL GNOME Shell logs...${NC}"
        echo
        ssh "$VM_DOMAIN" "journalctl -f -o cat /usr/bin/gnome-shell 2>/dev/null"
    else
        echo -e "${BLUE}Filtering for 'zoned' messages (use 'make vm-logs all' for all)...${NC}"
        echo
        ssh "$VM_DOMAIN" "journalctl -f -o cat /usr/bin/gnome-shell 2>/dev/null | grep --line-buffered -i zoned"
    fi
}

main "$@"
