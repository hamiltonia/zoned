#!/bin/bash
# Unified Test Runner - Handles both local and VM testing
# Usage: test <type> [--local] [args...]
#   Types: mem, func (future)
#   Default: Run in VM via SSH (most common workflow)
#   --local: Run on current machine

set -e

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source the shared VM detection library
source "$SCRIPT_DIR/lib/vm-detect.sh"

# Color codes
COLOR_RESET='\033[0m'
COLOR_INFO='\033[36m'
COLOR_SUCCESS='\033[32m'
COLOR_ERROR='\033[31m'
COLOR_WARN='\033[33m'

# Detect VM for test execution
detect_vm_for_test() {
    # Try to use active profile first
    if vm_profile_read_active 2>/dev/null; then
        # Check if the cached VM is still running
        if vm_cache_is_valid 2>/dev/null; then
            # Active profile VM is running - use it
            printf "${COLOR_INFO}Using active profile: $VM_DOMAIN${COLOR_RESET}\n"
        else
            # Cached VM not running - need to detect
            unset VM_DOMAIN
        fi
    fi
    
    # If no valid cached VM, detect running VMs
    if [[ -z "$VM_DOMAIN" ]]; then
        local running_vms
        running_vms=$(vm_get_running)
        
        if [[ -z "$running_vms" ]]; then
            printf "${COLOR_ERROR}No VMs are currently running${COLOR_RESET}\n"
            printf "\n"
            printf "Start a VM first with: ./scripts/vm headless start\n"
            exit 1
        fi
        
        # Count running VMs
        local count
        count=$(echo "$running_vms" | wc -l)
        
        if [[ $count -eq 1 ]]; then
            VM_DOMAIN="$running_vms"
        else
            # Multiple VMs - prompt to select
            printf "${COLOR_INFO}Multiple VMs are running:${COLOR_RESET}\n"
            printf "\n"
            
            local vms=()
            local i=1
            while IFS= read -r vm; do
                [[ -z "$vm" ]] && continue
                local title=$(vm_get_title "$vm")
                printf "  %d) %s - \"%s\"\n" "$i" "$vm" "$title"
                vms+=("$vm")
                ((i++))
            done <<< "$running_vms"
            
            printf "\n"
            read -p "Select VM [1-${#vms[@]}]: " selection
            
            if [[ ! "$selection" =~ ^[0-9]+$ ]] || [[ $selection -lt 1 ]] || [[ $selection -gt ${#vms[@]} ]]; then
                printf "${COLOR_ERROR}Invalid selection${COLOR_RESET}\n"
                exit 1
            fi
            
            VM_DOMAIN="${vms[$((selection-1))]}"
        fi
    fi
    
    # Test SSH connection
    printf "${COLOR_INFO}Testing SSH connection to %s...${COLOR_RESET}\n" "$VM_DOMAIN"
    if ! ssh -o ConnectTimeout=5 -o BatchMode=yes "$VM_DOMAIN" "exit" 2>/dev/null; then
        printf "${COLOR_ERROR}Cannot connect to VM: %s${COLOR_RESET}\n" "$VM_DOMAIN"
        printf "\n"
        printf "Run './scripts/vm setup' first to configure SSH access.\n"
        exit 1
    fi
    
    # Use VM_MOUNT_PATH from profile (set by vm_profile_read_active)
    REMOTE_PROJECT_DIR="$VM_MOUNT_PATH"
    
    # Verify the mount is accessible
    if [[ -z "$REMOTE_PROJECT_DIR" ]]; then
        printf "${COLOR_ERROR}VM_MOUNT_PATH not set in profile${COLOR_RESET}\n"
        printf "\n"
        printf "Run './scripts/vm setup' to configure the VM mount.\n"
        exit 1
    fi
    
    printf "${COLOR_INFO}Verifying project files at %s...${COLOR_RESET}\n" "$REMOTE_PROJECT_DIR"
    if ! ssh "$VM_DOMAIN" "test -f '$REMOTE_PROJECT_DIR/extension/metadata.json'" 2>/dev/null; then
        printf "${COLOR_ERROR}Project files not accessible at %s${COLOR_RESET}\n" "$REMOTE_PROJECT_DIR"
        printf "\n"
        printf "Troubleshooting:\n"
        printf "  1. Run './scripts/vm setup' to reconfigure virtiofs mount\n"
        printf "  2. Ensure virtiofs is mounted: ssh %s 'mountpoint /mnt/zoned'\n" "$VM_DOMAIN"
        printf "  3. Check VM is running: virsh list\n"
        exit 1
    fi
    
    printf "${COLOR_SUCCESS}âœ“ Connected to VM: %s${COLOR_RESET}\n" "$VM_DOMAIN"
    printf "${COLOR_INFO}Project directory: %s${COLOR_RESET}\n" "$REMOTE_PROJECT_DIR"
}

show_help() {
    printf "${COLOR_INFO}Unified Test Runner${COLOR_RESET}\n"
    printf "\n"
    printf "${COLOR_SUCCESS}Usage:${COLOR_RESET} ./scripts/test <type> [--local] [args...]\n"
    printf "\n"
    printf "${COLOR_SUCCESS}Test Types:${COLOR_RESET}\n"
    printf "  ${COLOR_INFO}mem${COLOR_RESET}  - Memory leak testing with statistical analysis\n"
    printf "  ${COLOR_INFO}func${COLOR_RESET} - Functional regression testing (future)\n"
    printf "\n"
    printf "${COLOR_SUCCESS}Execution Mode:${COLOR_RESET}\n"
    printf "  ${COLOR_INFO}Default${COLOR_RESET}  - Run in VM via SSH (recommended)\n"
    printf "  ${COLOR_INFO}--local${COLOR_RESET} - Run on current machine\n"
    printf "\n"
    printf "${COLOR_SUCCESS}Memory Testing Examples:${COLOR_RESET}\n"
    printf "  ./scripts/test mem --preset quick     # Quick test in VM (1-3 min, ~6 min)\n"
    printf "  ./scripts/test mem --preset standard  # Standard test (1-10 min)\n"
    printf "  ./scripts/test mem --preset deep      # Deep analysis (1-20 min)\n"
    printf "  ./scripts/test mem --local --preset quick  # Local testing\n"
    printf "\n"
    printf "${COLOR_INFO}Note:${COLOR_RESET} Most testing happens in VM. Use --local for quick local verification.\n"
    printf "\n"
}

# Parse command
TEST_TYPE="${1:-}"
if [[ -z "$TEST_TYPE" ]]; then
    show_help
    exit 1
fi
shift

# Check for --local flag
RUN_LOCAL=false
if [[ "$1" == "--local" ]]; then
    RUN_LOCAL=true
    shift
fi

# Validate test type
case "$TEST_TYPE" in
    mem|memory)
        TEST_SCRIPT="./scripts/tests/test-mem"
        ;;
    func|functional)
        printf "${COLOR_ERROR}Functional tests not yet implemented${COLOR_RESET}\n"
        printf "${COLOR_INFO}Functional tests will use xdotool for real keyboard automation${COLOR_RESET}\n"
        exit 1
        ;;
    help|--help|-h)
        show_help
        exit 0
        ;;
    *)
        printf "${COLOR_ERROR}Unknown test type: $TEST_TYPE${COLOR_RESET}\n"
        printf "Available types: mem, func (future)\n"
        printf "\n"
        show_help
        exit 1
        ;;
esac

# Execute test
if [ "$RUN_LOCAL" = true ]; then
    # Local execution
    printf "${COLOR_INFO}Running tests locally...${COLOR_RESET}\n"
    printf "\n"
    exec "$TEST_SCRIPT" "$@"
else
    # VM execution (default)
    detect_vm_for_test
    
    # Build command with all args properly escaped
    CMD="cd $REMOTE_PROJECT_DIR && $TEST_SCRIPT"
    for arg in "$@"; do
        CMD="$CMD $(printf '%q' "$arg")"
    done
    
    # Execute on VM with TTY for interactive prompts
    printf "\n"
    printf "${COLOR_SUCCESS}Executing test on VM...${COLOR_RESET}\n"
    printf "\n"
    ssh -t "$VM_DOMAIN" "$CMD"
fi
