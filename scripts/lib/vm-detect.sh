#!/bin/bash
#
# vm-detect.sh - Shared VM detection and setup functions
#
# This library provides functions for auto-detecting running VMs
# and setting up SSH access. Used by vm-install, vm-logs, etc.
#

# Configuration
VIRSH_CONNECT="qemu:///session"
SSH_CONFIG="${HOME}/.ssh/config"
DEFAULT_USER="${USER}"

# Cache file location (project-local, gitignored)
VM_CACHE_FILE="${SCRIPT_DIR:-$(dirname "$0")/..}/../.vm-cache"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# ============================================
#  OUTPUT HELPERS
# ============================================

vm_print_info() { echo -e "${BLUE}ℹ${NC} $1"; }
vm_print_success() { echo -e "${GREEN}✓${NC} $1"; }
vm_print_warning() { echo -e "${YELLOW}⚠${NC} $1"; }
vm_print_error() { echo -e "${RED}✗${NC} $1" >&2; }
vm_print_step() { echo -e "${CYAN}▶${NC} $1"; }

# ============================================
#  CACHE FUNCTIONS
# ============================================

# Write cache file after successful setup
vm_write_cache() {
    local cache_file="$1"
    [[ -z "$cache_file" ]] && cache_file="$VM_CACHE_FILE"
    
    cat > "$cache_file" << EOF
# VM cache - auto-generated by vm-setup
# Do not edit manually. Run 'make vm-setup' to regenerate.
VM_DOMAIN=${VM_DOMAIN}
VM_IP=${VM_IP}
VM_USER=${VM_USER}
VM_MOUNT_PATH=${VM_MOUNT_PATH}
VM_SHARE_TYPE=${VM_SHARE_TYPE:-spice}
VM_LIBVIRT_NAME=${VM_LIBVIRT_NAME:-$VM_DOMAIN}
VM_CACHE_TIME=$(date +%s)
EOF
    vm_print_success "Cache saved: $cache_file"
}

# Read cache file
# Returns: 0 if cache exists and is valid, 1 otherwise
vm_read_cache() {
    local cache_file="$1"
    [[ -z "$cache_file" ]] && cache_file="$VM_CACHE_FILE"
    
    if [[ ! -f "$cache_file" ]]; then
        return 1
    fi
    
    # Source the cache file
    source "$cache_file"
    
    # Validate required fields
    if [[ -z "$VM_DOMAIN" ]] || [[ -z "$VM_MOUNT_PATH" ]]; then
        return 1
    fi
    
    return 0
}

# Check if cache is valid (VM is running and SSH works)
# Returns: 0 if valid, 1 if invalid
vm_cache_is_valid() {
    # Check if cached VM is running
    local running_vms
    running_vms=$(vm_get_running)
    
    if ! echo "$running_vms" | grep -qx "$VM_DOMAIN"; then
        vm_print_warning "Cached VM '$VM_DOMAIN' is not running"
        return 1
    fi
    
    # Check SSH connectivity
    if ! ssh -o ConnectTimeout=3 -o BatchMode=yes "$VM_DOMAIN" "exit" 2>/dev/null; then
        vm_print_warning "Cannot SSH to cached VM '$VM_DOMAIN'"
        return 1
    fi
    
    return 0
}

# ============================================
#  VM DETECTION FUNCTIONS
# ============================================

# Get list of running VM domain names
vm_get_running() {
    virsh --connect "$VIRSH_CONNECT" list --name 2>/dev/null | grep -v "^$"
}

# Get VM title (display name) from libvirt XML
vm_get_title() {
    local domain="$1"
    virsh --connect "$VIRSH_CONNECT" dumpxml "$domain" 2>/dev/null | \
        grep -oP '(?<=<title>).*(?=</title>)' || echo ""
}

# Get VM IP address (only works for running VMs)
vm_get_ip() {
    local domain="$1"
    virsh --connect "$VIRSH_CONNECT" domifaddr "$domain" 2>/dev/null | \
        awk '/ipv4/ {split($4,a,"/"); print a[1]; exit}'
}

# Check if SSH host exists in config
vm_ssh_host_exists() {
    local host="$1"
    [[ -f "$SSH_CONFIG" ]] && grep -qi "^Host ${host}$" "$SSH_CONFIG" 2>/dev/null
}

# Get HostName (IP) for an SSH host from config
vm_get_ssh_hostname() {
    local host="$1"
    # Use awk to find the Host block and extract HostName
    # This handles the case where the target Host is the last entry in the file
    awk -v target="$host" '
        /^Host / { 
            in_block = ($2 == target)
        }
        in_block && /HostName/ { 
            print $2
            exit
        }
    ' "$SSH_CONFIG" 2>/dev/null
}

# ============================================
#  VM SELECTION
# ============================================

# Detect and select the target VM
# Returns: Sets VM_DOMAIN, VM_IP, VM_TITLE, VM_USER variables
# Exit codes: 0 = success, 1 = no VMs running, 2 = user cancelled
vm_detect_target() {
    local running_vms
    running_vms=$(vm_get_running)
    
    if [[ -z "$running_vms" ]]; then
        vm_print_error "No VMs are currently running"
        echo ""
        echo "Start a VM in GNOME Boxes first, then run this command again."
        echo ""
        echo "If you don't have a VM yet:"
        echo "  1. Open GNOME Boxes"
        echo "  2. Create a new VM (Fedora or Ubuntu recommended)"
        echo "  3. Start the VM and complete the OS setup"
        echo "  4. Run 'make vm-dev' again"
        return 1
    fi
    
    # Count running VMs
    local count
    count=$(echo "$running_vms" | wc -l)
    
    if [[ $count -eq 1 ]]; then
        # Single VM running - use it
        VM_DOMAIN="$running_vms"
        VM_TITLE=$(vm_get_title "$VM_DOMAIN")
        VM_IP=$(vm_get_ip "$VM_DOMAIN")
        VM_USER="$DEFAULT_USER"
        
        vm_print_info "Detected running VM: ${CYAN}$VM_DOMAIN${NC} - \"$VM_TITLE\""
        return 0
    else
        # Multiple VMs running - prompt user to select
        echo -e "\n${CYAN}Multiple VMs are running:${NC}\n"
        
        local vms=()
        local i=1
        while IFS= read -r vm; do
            [[ -z "$vm" ]] && continue
            local title=$(vm_get_title "$vm")
            echo "  $i) $vm - \"$title\""
            vms+=("$vm")
            ((i++))
        done <<< "$running_vms"
        
        echo ""
        read -p "Select VM [1-${#vms[@]}]: " selection
        
        # Validate selection
        if [[ ! "$selection" =~ ^[0-9]+$ ]] || [[ $selection -lt 1 ]] || [[ $selection -gt ${#vms[@]} ]]; then
            vm_print_error "Invalid selection"
            return 2
        fi
        
        VM_DOMAIN="${vms[$((selection-1))]}"
        VM_TITLE=$(vm_get_title "$VM_DOMAIN")
        VM_IP=$(vm_get_ip "$VM_DOMAIN")
        VM_USER="$DEFAULT_USER"
        
        vm_print_info "Selected: ${CYAN}$VM_DOMAIN${NC}"
        return 0
    fi
}

# ============================================
#  SSH SETUP
# ============================================

# Ensure SSH access to the VM is configured
# Requires: VM_DOMAIN, VM_IP, VM_USER to be set
# Returns: 0 = success, 1 = failed
vm_ensure_ssh() {
    local domain="$VM_DOMAIN"
    local ip="$VM_IP"
    local user="$VM_USER"
    
    # First, try to get IP if we don't have it
    if [[ -z "$ip" ]]; then
        vm_print_step "Detecting VM IP address..."
        
        # Try virsh domifaddr (requires qemu-guest-agent)
        for i in {1..5}; do
            ip=$(vm_get_ip "$domain")
            [[ -n "$ip" ]] && break
            sleep 1
        done
        
        if [[ -z "$ip" ]]; then
            # Check if we have an SSH config entry with hostname
            if vm_ssh_host_exists "$domain"; then
                ip=$(vm_get_ssh_hostname "$domain")
                if [[ -n "$ip" ]]; then
                    vm_print_info "Using IP from SSH config: $ip"
                fi
            fi
        fi
        
        if [[ -z "$ip" ]]; then
            # Can't auto-detect - ask user
            vm_print_warning "Could not auto-detect IP address"
            echo ""
            echo "Auto-detection requires qemu-guest-agent, which may not be installed."
            echo ""
            echo -e "To find the VM's IP address, run this command ${YELLOW}IN THE VM${NC}:"
            echo ""
            echo "  ip addr show | grep 'inet ' | grep -v 127.0.0.1"
            echo ""
            echo "Look for an IP like 192.168.122.xxx"
            echo ""
            
            read -p "Enter VM IP address (or press Enter to abort): " ip
            
            if [[ -z "$ip" ]]; then
                vm_print_error "Aborted - no IP address provided"
                return 1
            fi
            
            # Validate IP format
            if [[ ! "$ip" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                vm_print_error "Invalid IP address format: $ip"
                return 1
            fi
        fi
        
        VM_IP="$ip"
        vm_print_success "VM IP: $ip"
    fi
    
    # Check if SSH entry exists
    if vm_ssh_host_exists "$domain"; then
        # Entry exists - check if IP matches
        local existing_ip
        existing_ip=$(vm_get_ssh_hostname "$domain")
        
        if [[ "$existing_ip" != "$ip" ]]; then
            vm_print_warning "SSH config IP mismatch: $existing_ip → $ip"
            vm_print_info "Updating SSH config..."
            # Use awk to update HostName for the correct Host block
            # This handles the case where the target Host is the last entry
            awk -v target="$domain" -v newip="$ip" '
                /^Host / { in_block = ($2 == target) }
                in_block && /^[[:space:]]*HostName / { 
                    sub(/HostName .*/, "HostName " newip)
                }
                { print }
            ' "$SSH_CONFIG" > "$SSH_CONFIG.tmp" && mv "$SSH_CONFIG.tmp" "$SSH_CONFIG"
            chmod 600 "$SSH_CONFIG"
            vm_print_success "SSH config updated"
        fi
    else
        # No entry - create one
        vm_print_step "Creating SSH config entry for $domain..."
        
        # Ensure .ssh directory exists
        mkdir -p "$HOME/.ssh"
        chmod 700 "$HOME/.ssh"
        
        # Add entry
        {
            echo ""
            echo "# Added by zoned vm-dev"
            echo "Host $domain"
            echo "    HostName $ip"
            echo "    User $user"
            echo "    StrictHostKeyChecking no"
            echo "    UserKnownHostsFile /dev/null"
            echo "    LogLevel ERROR"
        } >> "$SSH_CONFIG"
        
        chmod 600 "$SSH_CONFIG"
        vm_print_success "SSH config entry added"
    fi
    
    # Test SSH connection
    vm_print_step "Testing SSH connection..."
    
    if ssh -o ConnectTimeout=5 -o BatchMode=yes "$domain" "exit" 2>/dev/null; then
        vm_print_success "SSH connection OK (passwordless)"
        return 0
    fi
    
    # Passwordless auth failed - try with password
    vm_print_warning "Passwordless SSH not configured"
    echo ""
    echo "SSH keys need to be copied to the VM for passwordless access."
    echo "This is required for the development workflow."
    echo ""
    
    # Check if user has SSH keys
    if [[ ! -f "$HOME/.ssh/id_rsa.pub" ]] && [[ ! -f "$HOME/.ssh/id_ed25519.pub" ]]; then
        vm_print_info "No SSH key found. Generating one..."
        ssh-keygen -t ed25519 -N "" -f "$HOME/.ssh/id_ed25519"
        vm_print_success "SSH key generated"
    fi
    
    read -p "Copy SSH key to VM now? (requires VM password) [Y/n]: " confirm
    if [[ "${confirm,,}" == "n" ]]; then
        vm_print_error "SSH key copy cancelled. Cannot continue."
        return 1
    fi
    
    echo ""
    vm_print_info "Copying SSH key to $domain..."
    if ssh-copy-id -o StrictHostKeyChecking=no "$domain" 2>/dev/null; then
        vm_print_success "SSH key copied!"
        
        # Verify it works now
        if ssh -o ConnectTimeout=5 -o BatchMode=yes "$domain" "exit" 2>/dev/null; then
            vm_print_success "SSH connection verified"
            return 0
        fi
    fi
    
    vm_print_error "SSH setup failed"
    echo ""
    echo "Troubleshooting:"
    echo "  1. Make sure SSH server is installed in the VM:"
    echo "     Ubuntu/Debian: sudo apt install openssh-server"
    echo "     Fedora: sudo dnf install openssh-server"
    echo "  2. Make sure SSH service is running:"
    echo "     sudo systemctl enable --now sshd"
    echo "  3. Try manually: ssh-copy-id $domain"
    return 1
}

# ============================================
#  DEPENDENCY CHECKING
# ============================================

# Check if required packages are installed in VM
# Returns: 0 = all installed, 1 = some missing
vm_check_dependencies() {
    local domain="$VM_DOMAIN"
    
    vm_print_step "Checking VM dependencies..."
    
    # Check for essential commands
    local missing=()
    
    # glib-compile-schemas is required for extension
    if ! ssh "$domain" "command -v glib-compile-schemas" &>/dev/null; then
        missing+=("glib-compile-schemas")
    fi
    
    # gnome-extensions is required to enable extension
    if ! ssh "$domain" "command -v gnome-extensions" &>/dev/null; then
        missing+=("gnome-extensions")
    fi
    
    if [[ ${#missing[@]} -eq 0 ]]; then
        vm_print_success "All dependencies present"
        return 0
    fi
    
    vm_print_warning "Missing dependencies: ${missing[*]}"
    return 1
}

# Install dependencies in VM based on distro
vm_install_dependencies() {
    local domain="$VM_DOMAIN"
    
    # Detect distro
    local distro
    distro=$(ssh "$domain" "if [ -f /etc/os-release ]; then . /etc/os-release; echo \$ID; else echo unknown; fi" 2>/dev/null)
    
    vm_print_info "Detected distro: $distro"
    
    case "$distro" in
        ubuntu|debian|pop)
            vm_print_step "Installing dependencies (Ubuntu/Debian)..."
            ssh -t "$domain" "sudo apt update && sudo apt install -y gnome-shell-extension-prefs"
            ;;
        fedora)
            vm_print_step "Installing dependencies (Fedora)..."
            ssh -t "$domain" "sudo dnf install -y gnome-extensions-app"
            ;;
        arch|endeavouros|manjaro)
            vm_print_step "Installing dependencies (Arch)..."
            ssh -t "$domain" "sudo pacman -S --noconfirm gnome-shell-extensions"
            ;;
        *)
            vm_print_warning "Unknown distro: $distro"
            echo "Please install gnome-shell-extension-prefs manually"
            return 1
            ;;
    esac
    
    vm_print_success "Dependencies installed"
    return 0
}

# ============================================
#  FILE SHARING SELECTION
# ============================================

# Prompt user to select file sharing method
# Returns: Sets VM_SHARE_TYPE variable ("virtiofs" or "spice")
vm_select_share_type() {
    echo ""
    echo -e "${CYAN}Select file sharing method:${NC}"
    echo ""
    echo "  1) virtiofs (recommended)"
    echo "     - Faster, kernel-level file sharing"
    echo "     - Better for longhaul testing"
    echo "     - Requires one-time VM restart"
    echo ""
    echo "  2) SPICE WebDAV"
    echo "     - Works with GNOME Boxes out of the box"
    echo "     - Slower, uses GVFS mount"
    echo "     - Requires display client connection"
    echo ""
    
    read -p "Choose [1/2]: " choice
    
    case "$choice" in
        1|virtiofs)
            VM_SHARE_TYPE="virtiofs"
            ;;
        2|spice)
            VM_SHARE_TYPE="spice"
            ;;
        *)
            vm_print_warning "Invalid choice, defaulting to virtiofs"
            VM_SHARE_TYPE="virtiofs"
            ;;
    esac
    
    vm_print_info "Selected: $VM_SHARE_TYPE"
}

# Quick check if sharing is already working (called after reading cache)
# Returns: 0 if working, 1 if needs setup
vm_check_existing_mount() {
    local domain="${1:-$VM_DOMAIN}"
    local share_type="${2:-$VM_SHARE_TYPE}"
    
    case "$share_type" in
        virtiofs)
            if ssh "$domain" "mountpoint -q /mnt/zoned && test -f /mnt/zoned/extension/metadata.json" 2>/dev/null; then
                VM_MOUNT_PATH="/mnt/zoned"
                return 0
            fi
            ;;
        spice)
            local spice_mount
            spice_mount=$(ssh "$domain" "find /run/user/1000/gvfs -maxdepth 2 -name 'metadata.json' -path '*extension*' 2>/dev/null | head -1" 2>/dev/null || echo "")
            if [[ -n "$spice_mount" ]]; then
                # Extract base path (remove /extension/metadata.json)
                VM_MOUNT_PATH="${spice_mount%/extension/metadata.json}"
                return 0
            fi
            ;;
    esac
    
    return 1
}

# Setup file sharing based on selected type
# Calls the appropriate setup script
# Returns: 0 = success, 1 = failed, 2 = needs action (reboot, etc)
vm_setup_sharing() {
    local domain="${1:-$VM_DOMAIN}"
    local share_type="${2:-$VM_SHARE_TYPE}"
    
    # Source the appropriate setup script
    local lib_dir
    lib_dir="$(dirname "${BASH_SOURCE[0]}")"
    
    case "$share_type" in
        virtiofs)
            source "$lib_dir/vm-virtiofs-setup.sh"
            vm_virtiofs_setup "$domain"
            return $?
            ;;
        spice)
            source "$lib_dir/vm-spice-setup.sh"
            vm_spice_setup "$domain"
            return $?
            ;;
        *)
            vm_print_error "Unknown share type: $share_type"
            return 1
            ;;
    esac
}

# ============================================
#  VIRTIOFS PERMISSIONS
# ============================================

# Ensure virtiofs shared directory has correct permissions
# virtiofs passthrough mode preserves host UIDs/GIDs, causing permission issues
# This function makes files readable by all users to avoid permission denied errors
vm_ensure_virtiofs_permissions() {
    vm_print_step "Checking virtiofs permissions..."
    
    local share_path="$PROJECT_DIR"
    
    echo ""
    echo "virtiofs uses passthrough mode which preserves host UIDs/GIDs."
    echo "Making shared files readable by all users to avoid permission issues."
    echo ""
    
    vm_print_info "Setting permissions on: $share_path"
    
    # Use chmod to make everything readable
    # a+rX: add read for all users, and execute for directories (for traversal)
    if chmod -R a+rX "$share_path" 2>/dev/null; then
        vm_print_success "Permissions updated successfully"
    else
        vm_print_warning "Could not update some permissions (may need sudo)"
        read -p "Run with sudo to fix remaining permissions? [Y/n]: " response
        
        if [[ "${response,,}" != "n" ]]; then
            sudo chmod -R a+rX "$share_path"
            vm_print_success "Permissions updated with sudo"
        else
            vm_print_warning "Some files may not be accessible in VM"
            echo "  You can fix this manually later with:"
            echo "    chmod -R a+rX $share_path"
        fi
    fi
    echo ""
}

# ============================================
#  SPICE PACKAGE CHECK
# ============================================

# Check and optionally install SPICE packages for shared folders
vm_ensure_spice() {
    local domain="$VM_DOMAIN"
    
    vm_print_step "Checking SPICE shared folder support..."
    
    # Check if spice-webdavd is installed
    if ssh "$domain" "command -v /usr/sbin/spice-webdavd || command -v spice-webdavd" &>/dev/null; then
        vm_print_success "SPICE packages installed"
        return 0
    fi
    
    vm_print_warning "SPICE shared folder packages not installed"
    echo ""
    echo "These packages enable shared folders between host and VM."
    echo ""
    
    read -p "Install SPICE packages now? [Y/n]: " confirm
    if [[ "${confirm,,}" == "n" ]]; then
        return 1
    fi
    
    # Detect distro and install
    local distro
    distro=$(ssh "$domain" ". /etc/os-release 2>/dev/null; echo \$ID" || echo "unknown")
    
    case "$distro" in
        ubuntu|debian|pop)
            vm_print_step "Installing SPICE packages (Ubuntu/Debian)..."
            ssh -t "$domain" "sudo apt update && sudo apt install -y spice-vdagent spice-webdavd gvfs-backends"
            ;;
        fedora)
            vm_print_step "Installing SPICE packages (Fedora)..."
            ssh -t "$domain" "sudo dnf install -y spice-vdagent spice-webdavd"
            ;;
        arch|endeavouros|manjaro)
            vm_print_step "Installing SPICE packages (Arch)..."
            ssh -t "$domain" "sudo pacman -S --noconfirm spice-vdagent"
            ;;
        *)
            vm_print_warning "Unknown distro. Install spice-vdagent and spice-webdavd manually."
            return 1
            ;;
    esac
    
    # Enable service
    ssh "$domain" "systemctl --user enable spice-webdavd 2>/dev/null; systemctl --user start spice-webdavd 2>/dev/null" || true
    
    vm_print_success "SPICE packages installed"
    echo ""
    vm_print_warning "VM REBOOT REQUIRED for shared folders to work"
    echo "Please reboot the VM, then run 'make vm-dev' again."
    return 2  # Special return code indicating reboot needed
}
