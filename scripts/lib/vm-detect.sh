#!/bin/bash
#
# vm-detect.sh - Shared VM detection and setup functions
#
# This library provides functions for auto-detecting running VMs
# and setting up SSH access. Used by vm-install, vm-logs, etc.
#

# Configuration
VIRSH_CONNECT="qemu:///session"
SSH_CONFIG="${HOME}/.ssh/config"
DEFAULT_USER="${USER}"

# Profile system configuration
VM_PROFILES_DIR="${SCRIPT_DIR:-$(dirname "$0")/..}/../.vm-profiles"
VM_ACTIVE_PROFILE_LINK="$VM_PROFILES_DIR/active"

# Legacy cache file location (for migration)
VM_CACHE_FILE="${SCRIPT_DIR:-$(dirname "$0")/..}/../.vm-cache"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# ============================================
#  OUTPUT HELPERS
# ============================================

vm_print_info() { echo -e "${BLUE}ℹ${NC} $1"; }
vm_print_success() { echo -e "${GREEN}✓${NC} $1"; }
vm_print_warning() { echo -e "${YELLOW}⚠${NC} $1"; }
vm_print_error() { echo -e "${RED}✗${NC} $1" >&2; }
vm_print_step() { echo -e "${CYAN}▶${NC} $1"; }

# ============================================
#  PROFILE MANAGEMENT
# ============================================

# Initialize profiles directory
vm_profiles_init() {
    mkdir -p "$VM_PROFILES_DIR"
}

# List all available VM profiles
vm_profiles_list() {
    vm_profiles_init
    
    local profiles=()
    local active_profile=""
    
    # Get active profile if it exists
    if [[ -L "$VM_ACTIVE_PROFILE_LINK" ]]; then
        active_profile=$(basename "$(readlink "$VM_ACTIVE_PROFILE_LINK")" .profile)
    fi
    
    # List all profiles
    for profile_file in "$VM_PROFILES_DIR"/*.profile; do
        [[ -e "$profile_file" ]] || continue
        local name=$(basename "$profile_file" .profile)
        profiles+=("$name")
    done
    
    if [[ ${#profiles[@]} -eq 0 ]]; then
        echo "No VM profiles found."
        return 1
    fi
    
    echo -e "${CYAN}Available VM profiles:${NC}"
    echo ""
    for profile in "${profiles[@]}"; do
        if [[ "$profile" == "$active_profile" ]]; then
            echo -e "  ${GREEN}●${NC} $profile (active)"
        else
            echo "  ○ $profile"
        fi
    done
    echo ""
    return 0
}

# Get profile name for a VM domain (sanitize domain name)
vm_profile_name_for_domain() {
    local domain="$1"
    # Replace spaces and special chars with hyphens
    echo "$domain" | tr ' ' '-' | tr -cd '[:alnum:]-_'
}

# Write profile file
vm_profile_write() {
    local profile_name="${1:-$(vm_profile_name_for_domain "$VM_DOMAIN")}"
    
    vm_profiles_init
    
    local profile_file="$VM_PROFILES_DIR/${profile_name}.profile"
    
    cat > "$profile_file" << EOF
# VM Profile: $profile_name
# Auto-generated by vm-setup
# Domain: $VM_DOMAIN
VM_DOMAIN=${VM_DOMAIN}
VM_IP=${VM_IP}
VM_USER=${VM_USER}
VM_MOUNT_PATH=${VM_MOUNT_PATH}
VM_SHARE_TYPE=${VM_SHARE_TYPE:-spice}
VM_LIBVIRT_NAME=${VM_LIBVIRT_NAME:-$VM_DOMAIN}
VM_TITLE="${VM_TITLE:-}"
VM_PROFILE_TIME=$(date +%s)
EOF
    
    vm_print_success "Profile saved: $profile_name"
    
    # Set as active profile
    ln -sf "$(basename "$profile_file")" "$VM_ACTIVE_PROFILE_LINK"
    vm_print_info "Active profile: $profile_name"
}

# Read profile file
vm_profile_read() {
    local profile_name="$1"
    
    vm_profiles_init
    
    local profile_file="$VM_PROFILES_DIR/${profile_name}.profile"
    
    if [[ ! -f "$profile_file" ]]; then
        return 1
    fi
    
    # Source the profile file
    source "$profile_file"
    
    # Validate required fields
    if [[ -z "$VM_DOMAIN" ]] || [[ -z "$VM_MOUNT_PATH" ]]; then
        return 1
    fi
    
    return 0
}

# Read active profile
vm_profile_read_active() {
    vm_profiles_init
    
    if [[ ! -L "$VM_ACTIVE_PROFILE_LINK" ]]; then
        # Try legacy cache file for migration
        if [[ -f "$VM_CACHE_FILE" ]]; then
            vm_print_info "Migrating legacy cache to profile system..."
            source "$VM_CACHE_FILE"
            if [[ -n "$VM_DOMAIN" ]]; then
                local profile_name=$(vm_profile_name_for_domain "$VM_DOMAIN")
                vm_profile_write "$profile_name"
                return 0
            fi
        fi
        return 1
    fi
    
    local profile_file=$(readlink "$VM_ACTIVE_PROFILE_LINK")
    local profile_name=$(basename "$profile_file" .profile)
    
    vm_profile_read "$profile_name"
}

# Switch to a different profile
vm_profile_switch() {
    local profile_name="$1"
    
    vm_profiles_init
    
    local profile_file="$VM_PROFILES_DIR/${profile_name}.profile"
    
    if [[ ! -f "$profile_file" ]]; then
        vm_print_error "Profile not found: $profile_name"
        return 1
    fi
    
    # Read profile to validate
    if ! vm_profile_read "$profile_name"; then
        vm_print_error "Invalid profile: $profile_name"
        return 1
    fi
    
    # Set as active
    ln -sf "$(basename "$profile_file")" "$VM_ACTIVE_PROFILE_LINK"
    vm_print_success "Switched to profile: $profile_name"
    
    # Show profile info
    echo ""
    echo -e "  VM: ${CYAN}$VM_DOMAIN${NC}"
    echo -e "  IP: $VM_IP"
    echo -e "  Share: $VM_SHARE_TYPE ($VM_MOUNT_PATH)"
    echo ""
    
    return 0
}

# Legacy cache functions (for backward compatibility)
vm_write_cache() {
    # Now just calls profile write
    vm_profile_write
}

vm_read_cache() {
    # Now just calls profile read active
    vm_profile_read_active
}

# Check if cache is valid (VM is running and SSH works)
# Returns: 0 if valid, 1 if invalid
vm_cache_is_valid() {
    # Check if cached VM is running
    local running_vms
    running_vms=$(vm_get_running)
    
    if ! echo "$running_vms" | grep -qx "$VM_DOMAIN"; then
        vm_print_warning "Cached VM '$VM_DOMAIN' is not running"
        return 1
    fi
    
    # Check SSH connectivity
    if ! ssh -o ConnectTimeout=3 -o BatchMode=yes "$VM_DOMAIN" "exit" 2>/dev/null; then
        vm_print_warning "Cannot SSH to cached VM '$VM_DOMAIN'"
        return 1
    fi
    
    return 0
}

# ============================================
#  VM DETECTION FUNCTIONS
# ============================================

# Get list of running VM domain names
vm_get_running() {
    virsh --connect "$VIRSH_CONNECT" list --name 2>/dev/null | grep -v "^$"
}

# Get VM title (display name) from libvirt XML
vm_get_title() {
    local domain="$1"
    virsh --connect "$VIRSH_CONNECT" dumpxml "$domain" 2>/dev/null | \
        grep -oP '(?<=<title>).*(?=</title>)' || echo ""
}

# Get VM IP address (only works for running VMs)
vm_get_ip() {
    local domain="$1"
    virsh --connect "$VIRSH_CONNECT" domifaddr "$domain" 2>/dev/null | \
        awk '/ipv4/ {split($4,a,"/"); print a[1]; exit}'
}

# Check if qemu-guest-agent is installed and running in VM
vm_check_qemu_agent() {
    local domain="$1"
    
    # Try to check via SSH (requires SSH to be working)
    if ssh -o ConnectTimeout=3 -o BatchMode=yes "$domain" "systemctl is-active qemu-guest-agent" &>/dev/null; then
        return 0
    fi
    return 1
}

# Install and enable qemu-guest-agent in VM
vm_install_qemu_agent() {
    local domain="$1"
    
    # Detect distro
    local distro
    distro=$(ssh "$domain" ". /etc/os-release 2>/dev/null; echo \$ID" || echo "unknown")
    
    vm_print_info "Installing qemu-guest-agent ($distro)..."
    
    case "$distro" in
        ubuntu|debian|pop)
            ssh -t "$domain" "sudo apt update && sudo apt install -y qemu-guest-agent && sudo systemctl enable --now qemu-guest-agent"
            ;;
        fedora)
            ssh -t "$domain" "sudo dnf install -y qemu-guest-agent && sudo systemctl enable --now qemu-guest-agent"
            ;;
        arch|endeavouros|manjaro)
            ssh -t "$domain" "sudo pacman -S --noconfirm qemu-guest-agent && sudo systemctl enable --now qemu-guest-agent"
            ;;
        *)
            vm_print_warning "Unknown distro: $distro"
            echo "Please install qemu-guest-agent manually"
            return 1
            ;;
    esac
    
    if [[ $? -eq 0 ]]; then
        vm_print_success "qemu-guest-agent installed and started"
        # Give it a moment to initialize
        sleep 2
        return 0
    else
        vm_print_error "Failed to install qemu-guest-agent"
        return 1
    fi
}

# Check if SSH host exists in config
vm_ssh_host_exists() {
    local host="$1"
    [[ -f "$SSH_CONFIG" ]] && grep -qi "^Host ${host}$" "$SSH_CONFIG" 2>/dev/null
}

# Get HostName (IP) for an SSH host from config
vm_get_ssh_hostname() {
    local host="$1"
    # Use awk to find the Host block and extract HostName
    # This handles the case where the target Host is the last entry in the file
    awk -v target="$host" '
        /^Host / { 
            in_block = ($2 == target)
        }
        in_block && /HostName/ { 
            print $2
            exit
        }
    ' "$SSH_CONFIG" 2>/dev/null
}

# ============================================
#  VM SELECTION
# ============================================

# Detect and select the target VM
# Returns: Sets VM_DOMAIN, VM_IP, VM_TITLE, VM_USER variables
# Exit codes: 0 = success, 1 = no VMs running, 2 = user cancelled
vm_detect_target() {
    local running_vms
    running_vms=$(vm_get_running)
    
    if [[ -z "$running_vms" ]]; then
        vm_print_error "No VMs are currently running"
        echo ""
        echo "Start a VM in GNOME Boxes first, then run this command again."
        echo ""
        echo "If you don't have a VM yet:"
        echo "  1. Open GNOME Boxes"
        echo "  2. Create a new VM (Fedora or Ubuntu recommended)"
        echo "  3. Start the VM and complete the OS setup"
        echo "  4. Run 'make vm-dev' again"
        return 1
    fi
    
    # Count running VMs
    local count
    count=$(echo "$running_vms" | wc -l)
    
    if [[ $count -eq 1 ]]; then
        # Single VM running - use it
        VM_DOMAIN="$running_vms"
        VM_TITLE=$(vm_get_title "$VM_DOMAIN")
        VM_IP=$(vm_get_ip "$VM_DOMAIN")
        VM_USER="$DEFAULT_USER"
        
        vm_print_info "Detected running VM: ${CYAN}$VM_DOMAIN${NC} - \"$VM_TITLE\""
        return 0
    else
        # Multiple VMs running - prompt user to select
        echo -e "\n${CYAN}Multiple VMs are running:${NC}\n"
        
        local vms=()
        local i=1
        while IFS= read -r vm; do
            [[ -z "$vm" ]] && continue
            local title=$(vm_get_title "$vm")
            echo "  $i) $vm - \"$title\""
            vms+=("$vm")
            ((i++))
        done <<< "$running_vms"
        
        echo ""
        read -p "Select VM [1-${#vms[@]}]: " selection
        
        # Validate selection
        if [[ ! "$selection" =~ ^[0-9]+$ ]] || [[ $selection -lt 1 ]] || [[ $selection -gt ${#vms[@]} ]]; then
            vm_print_error "Invalid selection"
            return 2
        fi
        
        VM_DOMAIN="${vms[$((selection-1))]}"
        VM_TITLE=$(vm_get_title "$VM_DOMAIN")
        VM_IP=$(vm_get_ip "$VM_DOMAIN")
        VM_USER="$DEFAULT_USER"
        
        vm_print_info "Selected: ${CYAN}$VM_DOMAIN${NC}"
        return 0
    fi
}

# ============================================
#  SSH SETUP
# ============================================

# Ensure SSH access to the VM is configured
# Requires: VM_DOMAIN, VM_IP, VM_USER to be set
# Returns: 0 = success, 1 = failed
vm_ensure_ssh() {
    local domain="$VM_DOMAIN"
    local ip="$VM_IP"
    local user="$VM_USER"
    
    # First, try to get IP if we don't have it
    if [[ -z "$ip" ]]; then
        vm_print_step "Detecting VM IP address..."
        
        # Try virsh domifaddr (requires qemu-guest-agent)
        for i in {1..5}; do
            ip=$(vm_get_ip "$domain")
            [[ -n "$ip" ]] && break
            sleep 1
        done
        
        if [[ -z "$ip" ]]; then
            # Check if we have an SSH config entry with hostname
            if vm_ssh_host_exists "$domain"; then
                ip=$(vm_get_ssh_hostname "$domain")
                if [[ -n "$ip" ]]; then
                    vm_print_info "Using IP from SSH config: $ip"
                fi
            fi
        fi
        
        if [[ -z "$ip" ]]; then
            # Can't auto-detect - provide detailed help
            vm_print_warning "Could not auto-detect IP address"
            echo ""
            echo "Auto-detection requires qemu-guest-agent to be running in the VM."
            echo ""
            echo -e "${CYAN}Option 1: Find IP manually (quick)${NC}"
            echo -e "  Run this command ${YELLOW}IN THE VM${NC}:"
            echo "    ip addr show | grep 'inet ' | grep -v 127.0.0.1"
            echo "  Look for an IP like 192.168.122.xxx"
            echo ""
            echo -e "${CYAN}Option 2: Install qemu-guest-agent (better long-term)${NC}"
            echo "  This enables automatic IP detection and better VM integration."
            echo "  We can install it via SSH if you already know the IP."
            echo ""
            
            read -p "Enter VM IP address (or 'q' to abort): " ip
            
            if [[ -z "$ip" ]] || [[ "$ip" == "q" ]]; then
                vm_print_error "Aborted - no IP address provided"
                return 1
            fi
            
            # Validate IP format
            if [[ ! "$ip" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                vm_print_error "Invalid IP address format: $ip"
                return 1
            fi
            
            # Temporarily set IP for SSH attempts
            VM_IP="$ip"
            
            # Offer to install qemu-guest-agent if SSH works
            echo ""
            vm_print_step "Testing SSH connection to $ip..."
            if ssh -o ConnectTimeout=5 "$user@$ip" "exit" 2>/dev/null || ssh -o ConnectTimeout=5 "$domain" "exit" 2>/dev/null; then
                vm_print_success "SSH works!"
                echo ""
                read -p "Install qemu-guest-agent for automatic IP detection? [Y/n]: " install_agent
                if [[ "${install_agent,,}" != "n" ]]; then
                    if vm_install_qemu_agent "$domain"; then
                        vm_print_info "IP detection will work automatically from now on"
                    fi
                fi
            fi
        fi
        
        VM_IP="$ip"
        vm_print_success "VM IP: $ip"
    fi
    
    # Check if SSH entry exists
    if vm_ssh_host_exists "$domain"; then
        # Entry exists - check if IP matches
        local existing_ip
        existing_ip=$(vm_get_ssh_hostname "$domain")
        
        if [[ "$existing_ip" != "$ip" ]]; then
            vm_print_warning "SSH config IP mismatch: $existing_ip → $ip"
            vm_print_info "Updating SSH config..."
            # Use awk to update HostName for the correct Host block
            # This handles the case where the target Host is the last entry
            awk -v target="$domain" -v newip="$ip" '
                /^Host / { in_block = ($2 == target) }
                in_block && /^[[:space:]]*HostName / { 
                    sub(/HostName .*/, "HostName " newip)
                }
                { print }
            ' "$SSH_CONFIG" > "$SSH_CONFIG.tmp" && mv "$SSH_CONFIG.tmp" "$SSH_CONFIG"
            chmod 600 "$SSH_CONFIG"
            vm_print_success "SSH config updated"
        fi
    else
        # No entry - create one
        vm_print_step "Creating SSH config entry for $domain..."
        
        # Ensure .ssh directory exists
        mkdir -p "$HOME/.ssh"
        chmod 700 "$HOME/.ssh"
        
        # Add entry
        {
            echo ""
            echo "# Added by zoned vm-dev"
            echo "Host $domain"
            echo "    HostName $ip"
            echo "    User $user"
            echo "    StrictHostKeyChecking no"
            echo "    UserKnownHostsFile /dev/null"
            echo "    LogLevel ERROR"
        } >> "$SSH_CONFIG"
        
        chmod 600 "$SSH_CONFIG"
        vm_print_success "SSH config entry added"
    fi
    
    # Test SSH connection
    vm_print_step "Testing SSH connection..."
    
    if ssh -o ConnectTimeout=5 -o BatchMode=yes "$domain" "exit" 2>/dev/null; then
        vm_print_success "SSH connection OK (passwordless)"
        return 0
    fi
    
    # Passwordless auth failed - try with password
    vm_print_warning "Passwordless SSH not configured"
    echo ""
    echo "SSH keys need to be copied to the VM for passwordless access."
    echo "This is required for the development workflow."
    echo ""
    
    # Check if user has SSH keys
    if [[ ! -f "$HOME/.ssh/id_rsa.pub" ]] && [[ ! -f "$HOME/.ssh/id_ed25519.pub" ]]; then
        vm_print_info "No SSH key found. Generating one..."
        ssh-keygen -t ed25519 -N "" -f "$HOME/.ssh/id_ed25519"
        vm_print_success "SSH key generated"
    fi
    
    read -p "Copy SSH key to VM now? (requires VM password) [Y/n]: " confirm
    if [[ "${confirm,,}" == "n" ]]; then
        vm_print_error "SSH key copy cancelled. Cannot continue."
        return 1
    fi
    
    echo ""
    vm_print_info "Copying SSH key to $domain..."
    if ssh-copy-id -o StrictHostKeyChecking=no "$domain" 2>/dev/null; then
        vm_print_success "SSH key copied!"
        
        # Verify it works now
        if ssh -o ConnectTimeout=5 -o BatchMode=yes "$domain" "exit" 2>/dev/null; then
            vm_print_success "SSH connection verified"
            return 0
        fi
    fi
    
    vm_print_error "SSH setup failed"
    echo ""
    echo "Troubleshooting:"
    echo "  1. Make sure SSH server is installed in the VM:"
    echo "     Ubuntu/Debian: sudo apt install openssh-server"
    echo "     Fedora: sudo dnf install openssh-server"
    echo "  2. Make sure SSH service is running:"
    echo "     sudo systemctl enable --now sshd"
    echo "  3. Try manually: ssh-copy-id $domain"
    return 1
}

# ============================================
#  DEPENDENCY CHECKING
# ============================================

# Check if required packages are installed in VM
# Returns: 0 = all installed, 1 = some missing
vm_check_dependencies() {
    local domain="$VM_DOMAIN"
    
    vm_print_step "Checking VM dependencies..."
    
    # Check for essential commands
    local missing=()
    
    # glib-compile-schemas is required for extension
    if ! ssh "$domain" "command -v glib-compile-schemas" &>/dev/null; then
        missing+=("glib-compile-schemas")
    fi
    
    # gnome-extensions is required to enable extension
    if ! ssh "$domain" "command -v gnome-extensions" &>/dev/null; then
        missing+=("gnome-extensions")
    fi
    
    if [[ ${#missing[@]} -eq 0 ]]; then
        vm_print_success "All dependencies present"
        return 0
    fi
    
    vm_print_warning "Missing dependencies: ${missing[*]}"
    return 1
}

# Install dependencies in VM based on distro
vm_install_dependencies() {
    local domain="$VM_DOMAIN"
    
    # Detect distro
    local distro
    distro=$(ssh "$domain" "if [ -f /etc/os-release ]; then . /etc/os-release; echo \$ID; else echo unknown; fi" 2>/dev/null)
    
    vm_print_info "Detected distro: $distro"
    
    case "$distro" in
        ubuntu|debian|pop)
            vm_print_step "Installing dependencies (Ubuntu/Debian)..."
            ssh -t "$domain" "sudo apt update && sudo apt install -y gnome-shell-extension-prefs"
            ;;
        fedora)
            vm_print_step "Installing dependencies (Fedora)..."
            ssh -t "$domain" "sudo dnf install -y gnome-extensions-app"
            ;;
        arch|endeavouros|manjaro)
            vm_print_step "Installing dependencies (Arch)..."
            ssh -t "$domain" "sudo pacman -S --noconfirm gnome-shell-extensions"
            ;;
        *)
            vm_print_warning "Unknown distro: $distro"
            echo "Please install gnome-shell-extension-prefs manually"
            return 1
            ;;
    esac
    
    vm_print_success "Dependencies installed"
    return 0
}

# ============================================
#  FILE SHARING SELECTION
# ============================================

# Prompt user to select file sharing method
# Returns: Sets VM_SHARE_TYPE variable ("virtiofs" or "spice")
vm_select_share_type() {
    echo ""
    echo -e "${CYAN}Select file sharing method:${NC}"
    echo ""
    echo "  1) virtiofs (recommended)"
    echo "     - Faster, kernel-level file sharing"
    echo "     - Better for longhaul testing"
    echo "     - Requires one-time VM restart"
    echo ""
    echo "  2) SPICE WebDAV"
    echo "     - Works with GNOME Boxes out of the box"
    echo "     - Slower, uses GVFS mount"
    echo "     - Requires display client connection"
    echo ""
    
    read -p "Choose [1/2]: " choice
    
    case "$choice" in
        1|virtiofs)
            VM_SHARE_TYPE="virtiofs"
            ;;
        2|spice)
            VM_SHARE_TYPE="spice"
            ;;
        *)
            vm_print_warning "Invalid choice, defaulting to virtiofs"
            VM_SHARE_TYPE="virtiofs"
            ;;
    esac
    
    vm_print_info "Selected: $VM_SHARE_TYPE"
}

# Smart mount re-discovery for existing VMs
# Returns: 0 if working, 1 if needs setup
vm_check_existing_mount() {
    local domain="${1:-$VM_DOMAIN}"
    local share_type="${2:-$VM_SHARE_TYPE}"
    
    case "$share_type" in
        virtiofs)
            # Check if already mounted
            if ssh "$domain" "mountpoint -q /mnt/zoned && test -f /mnt/zoned/extension/metadata.json" 2>/dev/null; then
                VM_MOUNT_PATH="/mnt/zoned"
                vm_print_success "virtiofs mount is active: /mnt/zoned"
                return 0
            fi
            
            # Check if it's in fstab but not mounted (e.g., after reboot without automount)
            if ssh "$domain" "grep -q '^zoned[[:space:]]' /etc/fstab" 2>/dev/null; then
                vm_print_warning "virtiofs in fstab but not mounted"
                vm_print_step "Attempting to mount..."
                
                if ssh "$domain" "sudo mount /mnt/zoned" 2>/dev/null; then
                    if ssh "$domain" "test -f /mnt/zoned/extension/metadata.json" 2>/dev/null; then
                        VM_MOUNT_PATH="/mnt/zoned"
                        vm_print_success "virtiofs re-mounted successfully"
                        return 0
                    fi
                fi
                vm_print_warning "Auto-mount failed, will need manual setup"
            fi
            ;;
        spice)
            # SPICE mounts have dynamic paths - always re-discover
            vm_print_step "Scanning for SPICE mount..."
            local spice_mount
            
            # Search for metadata.json in GVFS mounts
            spice_mount=$(ssh "$domain" "find /run/user/\$(id -u)/gvfs -maxdepth 3 -name 'metadata.json' -path '*extension*' 2>/dev/null | head -1" 2>/dev/null || echo "")
            
            if [[ -n "$spice_mount" ]]; then
                # Extract base path (remove /extension/metadata.json)
                VM_MOUNT_PATH="${spice_mount%/extension/metadata.json}"
                vm_print_success "SPICE mount found: $VM_MOUNT_PATH"
                return 0
            fi
            
            # Check legacy mount path
            local legacy_path="/run/user/\$(id -u)/spice-client-folder"
            if ssh "$domain" "test -f $legacy_path/extension/metadata.json" 2>/dev/null; then
                VM_MOUNT_PATH=$(ssh "$domain" "echo $legacy_path" 2>/dev/null)
                vm_print_success "SPICE mount found (legacy): $VM_MOUNT_PATH"
                return 0
            fi
            
            vm_print_warning "SPICE mount not found"
            echo ""
            echo "The SPICE shared folder is not currently mounted."
            echo ""
            echo "To mount it:"
            echo "  1. Open file manager in the VM"
            echo "  2. Click 'Other Locations' → 'Spice client folder'"
            echo ""
            ;;
    esac
    
    return 1
}

# Setup file sharing based on selected type
# Calls the appropriate setup script
# Returns: 0 = success, 1 = failed, 2 = needs action (reboot, etc)
vm_setup_sharing() {
    local domain="${1:-$VM_DOMAIN}"
    local share_type="${2:-$VM_SHARE_TYPE}"
    
    # Source the appropriate setup script
    local lib_dir
    lib_dir="$(dirname "${BASH_SOURCE[0]}")"
    
    case "$share_type" in
        virtiofs)
            source "$lib_dir/vm-virtiofs-setup.sh"
            vm_virtiofs_setup "$domain"
            return $?
            ;;
        spice)
            source "$lib_dir/vm-spice-setup.sh"
            vm_spice_setup "$domain"
            return $?
            ;;
        *)
            vm_print_error "Unknown share type: $share_type"
            return 1
            ;;
    esac
}

# ============================================
#  VIRTIOFS PERMISSIONS
# ============================================

# Ensure virtiofs shared directory has correct permissions
# virtiofs passthrough mode preserves host UIDs/GIDs, causing permission issues
# This function makes files readable by all users to avoid permission denied errors
vm_ensure_virtiofs_permissions() {
    vm_print_step "Checking virtiofs permissions..."
    
    local share_path="$PROJECT_DIR"
    
    echo ""
    echo "virtiofs uses passthrough mode which preserves host UIDs/GIDs."
    echo "Making shared files readable by all users to avoid permission issues."
    echo ""
    
    vm_print_info "Setting permissions on: $share_path"
    
    # Use chmod to make everything readable
    # a+rX: add read for all users, and execute for directories (for traversal)
    if chmod -R a+rX "$share_path" 2>/dev/null; then
        vm_print_success "Permissions updated successfully"
    else
        vm_print_warning "Could not update some permissions (may need sudo)"
        read -p "Run with sudo to fix remaining permissions? [Y/n]: " response
        
        if [[ "${response,,}" != "n" ]]; then
            sudo chmod -R a+rX "$share_path"
            vm_print_success "Permissions updated with sudo"
        else
            vm_print_warning "Some files may not be accessible in VM"
            echo "  You can fix this manually later with:"
            echo "    chmod -R a+rX $share_path"
        fi
    fi
    echo ""
}

# ============================================
#  SPICE PACKAGE CHECK
# ============================================

# Check and optionally install SPICE packages for shared folders
vm_ensure_spice() {
    local domain="$VM_DOMAIN"
    
    vm_print_step "Checking SPICE shared folder support..."
    
    # Check if spice-webdavd is installed
    if ssh "$domain" "command -v /usr/sbin/spice-webdavd || command -v spice-webdavd" &>/dev/null; then
        vm_print_success "SPICE packages installed"
        return 0
    fi
    
    vm_print_warning "SPICE shared folder packages not installed"
    echo ""
    echo "These packages enable shared folders between host and VM."
    echo ""
    
    read -p "Install SPICE packages now? [Y/n]: " confirm
    if [[ "${confirm,,}" == "n" ]]; then
        return 1
    fi
    
    # Detect distro and install
    local distro
    distro=$(ssh "$domain" ". /etc/os-release 2>/dev/null; echo \$ID" || echo "unknown")
    
    case "$distro" in
        ubuntu|debian|pop)
            vm_print_step "Installing SPICE packages (Ubuntu/Debian)..."
            ssh -t "$domain" "sudo apt update && sudo apt install -y spice-vdagent spice-webdavd gvfs-backends"
            ;;
        fedora)
            vm_print_step "Installing SPICE packages (Fedora)..."
            ssh -t "$domain" "sudo dnf install -y spice-vdagent spice-webdavd"
            ;;
        arch|endeavouros|manjaro)
            vm_print_step "Installing SPICE packages (Arch)..."
            ssh -t "$domain" "sudo pacman -S --noconfirm spice-vdagent"
            ;;
        *)
            vm_print_warning "Unknown distro. Install spice-vdagent and spice-webdavd manually."
            return 1
            ;;
    esac
    
    # Enable service
    ssh "$domain" "systemctl --user enable spice-webdavd 2>/dev/null; systemctl --user start spice-webdavd 2>/dev/null" || true
    
    vm_print_success "SPICE packages installed"
    echo ""
    vm_print_warning "VM REBOOT REQUIRED for shared folders to work"
    echo "Please reboot the VM, then run 'make vm-dev' again."
    return 2  # Special return code indicating reboot needed
}
