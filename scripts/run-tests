#!/bin/bash
# Unified Test Runner - Handles both local and VM testing
# Usage: test <type> [--local] [args...]
#   Types: mem, func (future)
#   Default: Run in VM via SSH (most common workflow)
#   --local: Run on current machine

set -e

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source the shared VM detection library
source "$SCRIPT_DIR/lib/vm-detect.sh"

# Color codes
COLOR_RESET='\033[0m'
COLOR_INFO='\033[36m'
COLOR_SUCCESS='\033[32m'
COLOR_ERROR='\033[31m'
COLOR_WARN='\033[33m'

# Detect VM for test execution
detect_vm_for_test() {
    # Try to use active profile first
    if vm_profile_read_active 2>/dev/null; then
        # Check if the cached VM is still running
        if vm_cache_is_valid 2>/dev/null; then
            # Active profile VM is running - use it
            printf "${COLOR_INFO}Using active profile: $VM_DOMAIN${COLOR_RESET}\n"
        else
            # Cached VM not running - need to detect
            unset VM_DOMAIN
        fi
    fi
    
    # If no valid cached VM, detect running VMs
    if [[ -z "$VM_DOMAIN" ]]; then
        local running_vms
        running_vms=$(vm_get_running)
        
        if [[ -z "$running_vms" ]]; then
            printf "${COLOR_ERROR}No VMs are currently running${COLOR_RESET}\n"
            printf "\n"
            printf "Start a VM first with: ./scripts/vm headless start\n"
            exit 1
        fi
        
        # Count running VMs
        local count
        count=$(echo "$running_vms" | wc -l)
        
        if [[ $count -eq 1 ]]; then
            VM_DOMAIN="$running_vms"
        else
            # Multiple VMs - prompt to select
            printf "${COLOR_INFO}Multiple VMs are running:${COLOR_RESET}\n"
            printf "\n"
            
            local vms=()
            local i=1
            while IFS= read -r vm; do
                [[ -z "$vm" ]] && continue
                local title=$(vm_get_title "$vm")
                printf "  %d) %s - \"%s\"\n" "$i" "$vm" "$title"
                vms+=("$vm")
                ((i++))
            done <<< "$running_vms"
            
            printf "\n"
            read -p "Select VM [1-${#vms[@]}]: " selection
            
            if [[ ! "$selection" =~ ^[0-9]+$ ]] || [[ $selection -lt 1 ]] || [[ $selection -gt ${#vms[@]} ]]; then
                printf "${COLOR_ERROR}Invalid selection${COLOR_RESET}\n"
                exit 1
            fi
            
            VM_DOMAIN="${vms[$((selection-1))]}"
        fi
    fi
    
    # Test SSH connection
    printf "${COLOR_INFO}Testing SSH connection to %s...${COLOR_RESET}\n" "$VM_DOMAIN"
    if ! ssh -o ConnectTimeout=5 -o BatchMode=yes "$VM_DOMAIN" "exit" 2>/dev/null; then
        printf "${COLOR_ERROR}Cannot connect to VM: %s${COLOR_RESET}\n" "$VM_DOMAIN"
        printf "\n"
        printf "Run './scripts/vm setup' first to configure SSH access.\n"
        exit 1
    fi
    
    # Use VM_MOUNT_PATH from profile (set by vm_profile_read_active)
    REMOTE_PROJECT_DIR="$VM_MOUNT_PATH"
    
    # Verify the mount is accessible
    if [[ -z "$REMOTE_PROJECT_DIR" ]]; then
        printf "${COLOR_ERROR}VM_MOUNT_PATH not set in profile${COLOR_RESET}\n"
        printf "\n"
        printf "Run './scripts/vm setup' to configure the VM mount.\n"
        exit 1
    fi
    
    printf "${COLOR_INFO}Verifying project files at %s...${COLOR_RESET}\n" "$REMOTE_PROJECT_DIR"
    if ! ssh "$VM_DOMAIN" "test -f '$REMOTE_PROJECT_DIR/extension/metadata.json'" 2>/dev/null; then
        printf "${COLOR_ERROR}Project files not accessible at %s${COLOR_RESET}\n" "$REMOTE_PROJECT_DIR"
        printf "\n"
        printf "Troubleshooting:\n"
        printf "  1. Run './scripts/vm setup' to reconfigure virtiofs mount\n"
        printf "  2. Ensure virtiofs is mounted: ssh %s 'mountpoint /mnt/zoned'\n" "$VM_DOMAIN"
        printf "  3. Check VM is running: virsh list\n"
        exit 1
    fi
    
    printf "${COLOR_SUCCESS}✓ Connected to VM: %s${COLOR_RESET}\n" "$VM_DOMAIN"
    printf "${COLOR_INFO}Project directory: %s${COLOR_RESET}\n" "$REMOTE_PROJECT_DIR"
}

show_help() {
    printf "${COLOR_INFO}Unified Test Runner${COLOR_RESET}\n"
    printf "\n"
    printf "${COLOR_SUCCESS}Usage:${COLOR_RESET} ./scripts/test <type> [--local] [args...]\n"
    printf "\n"
    printf "${COLOR_SUCCESS}Test Types:${COLOR_RESET}\n"
    printf "  ${COLOR_INFO}mem${COLOR_RESET}          - Memory leak testing with statistical analysis\n"
    printf "  ${COLOR_INFO}func${COLOR_RESET}         - Functional correctness testing\n"
    printf "  ${COLOR_INFO}release${COLOR_RESET}      - Full suite (mem deep + all functional tests)\n"
    printf "  ${COLOR_INFO}release-test${COLOR_RESET} - Quick release validation (mem 2min + func)\n"
    printf "\n"
    printf "${COLOR_SUCCESS}Execution Mode:${COLOR_RESET}\n"
    printf "  ${COLOR_INFO}Default${COLOR_RESET}  - Run in VM via SSH (recommended)\n"
    printf "  ${COLOR_INFO}--local${COLOR_RESET} - Run on current machine\n"
    printf "\n"
    printf "${COLOR_SUCCESS}Examples:${COLOR_RESET}\n"
    printf "  ${COLOR_INFO}Quick verification (feature work):${COLOR_RESET}\n"
    printf "    ./scripts/test mem --preset quick    # Memory test (1-3 min, ~6 min)\n"
    printf "    ./scripts/test func                  # All functional tests\n"
    printf "    ./scripts/test release-test          # Quick release check (~5-10 min)\n"
    printf "\n"
    printf "  ${COLOR_INFO}Release preparation:${COLOR_RESET}\n"
    printf "    ./scripts/test release               # Full suite (mem deep + func)\n"
    printf "    ./scripts/test mem --preset deep     # Just memory (1-20 min)\n"
    printf "\n"
    printf "${COLOR_INFO}Note:${COLOR_RESET} Most testing happens in VM. Use --local for quick local verification.\n"
    printf "\n"
}

# Parse command
TEST_TYPE="${1:-}"
if [[ -z "$TEST_TYPE" ]]; then
    show_help
    exit 1
fi
shift

# Check for --local flag
RUN_LOCAL=false
if [[ "$1" == "--local" ]]; then
    RUN_LOCAL=true
    shift
fi

# Run functional tests helper
run_functional_tests() {
    local test_dir="$1"
    local failed=0
    local total=0
    
    # List of functional test scripts
    local func_tests=(
        "test-func-edge-cases.sh"
        "test-func-gsettings.sh"
        "test-func-layout-switching.sh"
        "test-func-multi-monitor.sh"
        "test-func-window-movement.sh"
        "test-func-workspace.sh"
        "test-func-zone-cycling.sh"
    )
    
    printf "${COLOR_INFO}Running %d functional tests...${COLOR_RESET}\n" "${#func_tests[@]}"
    printf "\n"
    
    for test in "${func_tests[@]}"; do
        ((total++))
        printf "${COLOR_INFO}[%d/%d]${COLOR_RESET} %s\n" "$total" "${#func_tests[@]}" "$test"
        if "$test_dir/$test"; then
            printf "${COLOR_SUCCESS}✓ PASS${COLOR_RESET}\n\n"
        else
            printf "${COLOR_ERROR}✗ FAIL${COLOR_RESET}\n\n"
            ((failed++))
        fi
    done
    
    printf "${COLOR_INFO}Functional Tests Summary:${COLOR_RESET}\n"
    if [ $failed -eq 0 ]; then
        printf "${COLOR_SUCCESS}All %d tests passed${COLOR_RESET}\n" "$total"
        return 0
    else
        printf "${COLOR_ERROR}%d of %d tests failed${COLOR_RESET}\n" "$failed" "$total"
        return 1
    fi
}

# Validate test type
case "$TEST_TYPE" in
    mem|memory)
        TEST_SCRIPT="./scripts/tests/test-mem-with-restarts"
        ;;
    func|functional)
        # Run all functional tests
        if [ "$RUN_LOCAL" = true ]; then
            run_functional_tests "$SCRIPT_DIR/tests"
            exit $?
        else
            detect_vm_for_test
            printf "\n"
            printf "${COLOR_SUCCESS}Executing functional tests on VM...${COLOR_RESET}\n"
            printf "\n"
            # Run tests directly on VM with Ctrl+C handling
            trap 'kill $SSH_PID 2>/dev/null; exit 130' INT TERM
            ssh -t "$VM_DOMAIN" "cd $REMOTE_PROJECT_DIR && bash -c '
failed=0
total=0
for test in scripts/tests/test-func-*.sh; do
    total=\$((total + 1))
    test_name=\$(basename \"\$test\")
    printf \"[%d/6] %s\n\" \"\$total\" \"\$test_name\"
    if \"\$test\"; then
        printf \"✓ PASS\n\n\"
    else
        printf \"✗ FAIL\n\n\"
        failed=\$((failed + 1))
    fi
done

if [ \$failed -eq 0 ]; then
    printf \"Functional Tests Summary: All %d tests passed\n\" \"\$total\"
    exit 0
else
    printf \"Functional Tests Summary: %d of %d tests failed\n\" \"\$failed\" \"\$total\"
    exit 1
fi
'" &
            SSH_PID=$!
            wait $SSH_PID
            EXIT_CODE=$?
            trap - INT TERM
            exit $EXIT_CODE
        fi
        ;;
    release|release-test)
        # Determine preset based on test type
        if [ "$TEST_TYPE" = "release-test" ]; then
            MEM_PRESET="test"
            SUITE_NAME="release-test"
            printf "${COLOR_INFO}Running quick release validation suite...${COLOR_RESET}\n"
            printf "${COLOR_INFO}  1. Memory tests (2-minute max)${COLOR_RESET}\n"
            printf "${COLOR_INFO}  2. All functional tests${COLOR_RESET}\n"
        else
            MEM_PRESET="deep"
            SUITE_NAME="release"
            printf "${COLOR_INFO}Running full release test suite...${COLOR_RESET}\n"
            printf "${COLOR_INFO}  1. Memory tests (deep preset: 1-20 min)${COLOR_RESET}\n"
            printf "${COLOR_INFO}  2. All functional tests${COLOR_RESET}\n"
        fi
        printf "\n"
        
        if [ "$RUN_LOCAL" = true ]; then
            # Local execution
            MEM_EXIT=0
            FUNC_EXIT=0
            MEM_OUTPUT=$(mktemp)
            
            printf "${COLOR_INFO}=== Phase 1: Memory Tests ===${COLOR_RESET}\n"
            if ./scripts/tests/test-mem-with-restarts --preset "$MEM_PRESET" 2>&1 | tee "$MEM_OUTPUT"; then
                MEM_STATUS="PASS"
            else
                MEM_STATUS="FAIL"
                MEM_EXIT=1
            fi
            
            # Extract memory test summary info
            MEM_R2=$(grep -oP 'R²=\K[0-9.]+' "$MEM_OUTPUT" | tail -1 || echo "N/A")
            MEM_RANGE=$(grep -oP 'variance.*\K[0-9.]+(?= MB)' "$MEM_OUTPUT" | tail -1 || echo "N/A")
            rm -f "$MEM_OUTPUT"
            
            printf "\n"
            printf "${COLOR_INFO}=== Phase 2: Functional Tests ===${COLOR_RESET}\n"
            FUNC_PASSED=0
            FUNC_FAILED=0
            FUNC_TOTAL=0
            
            # Run functional tests and capture results
            local func_tests=(
                "test-func-edge-cases.sh"
                "test-func-gsettings.sh"
                "test-func-layout-switching.sh"
                "test-func-multi-monitor.sh"
                "test-func-window-movement.sh"
                "test-func-workspace.sh"
                "test-func-zone-cycling.sh"
            )
            
            for test in "${func_tests[@]}"; do
                ((FUNC_TOTAL++))
                printf "${COLOR_INFO}[%d/%d]${COLOR_RESET} %s\n" "$FUNC_TOTAL" "${#func_tests[@]}" "$test"
                if "$SCRIPT_DIR/tests/$test"; then
                    printf "${COLOR_SUCCESS}✓ PASS${COLOR_RESET}\n\n"
                    ((FUNC_PASSED++))
                else
                    printf "${COLOR_ERROR}✗ FAIL${COLOR_RESET}\n\n"
                    ((FUNC_FAILED++))
                    FUNC_EXIT=1
                fi
            done
            
            # Display summary
            printf "\n"
            printf "========================================\n"
            printf "  %s SUITE SUMMARY\n" "$(echo $SUITE_NAME | tr '[:lower:]' '[:upper:]')"
            printf "========================================\n"
            if [ "$MEM_R2" != "N/A" ]; then
                printf "  Memory Tests:     %s (R²=%s, range=%s MB)\n" "$MEM_STATUS" "$MEM_R2" "$MEM_RANGE"
            else
                printf "  Memory Tests:     %s\n" "$MEM_STATUS"
            fi
            printf "  Functional Tests: %d/%d PASS" "$FUNC_PASSED" "$FUNC_TOTAL"
            if [ $FUNC_FAILED -gt 0 ]; then
                printf ", %d/%d FAIL\n" "$FUNC_FAILED" "$FUNC_TOTAL"
            else
                printf "\n"
            fi
            printf "\n"
            if [ $MEM_EXIT -eq 0 ] && [ $FUNC_EXIT -eq 0 ]; then
                printf "  Overall Result:   ${COLOR_SUCCESS}PASS${COLOR_RESET}\n"
                printf "========================================\n"
                exit 0
            else
                printf "  Overall Result:   ${COLOR_ERROR}FAIL${COLOR_RESET}\n"
                printf "========================================\n"
                exit 1
            fi
        else
            # VM execution with summary and Ctrl+C handling
            detect_vm_for_test
            printf "\n"
            printf "${COLOR_SUCCESS}Executing $SUITE_NAME suite on VM...${COLOR_RESET}\n"
            printf "\n"
            
            trap 'kill $SSH_PID 2>/dev/null; exit 130' INT TERM
            ssh -t "$VM_DOMAIN" << EOF &
cd $REMOTE_PROJECT_DIR
MEM_EXIT=0
FUNC_EXIT=0
MEM_OUTPUT=\$(mktemp)

echo "=== Phase 1: Memory Tests ==="
if ./scripts/tests/test-mem-with-restarts --preset "$MEM_PRESET" 2>&1 | tee "\$MEM_OUTPUT"; then
    MEM_STATUS="PASS"
else
    MEM_STATUS="FAIL"
    MEM_EXIT=1
fi

# Extract memory test summary
MEM_R2=\$(grep -oP "R²=\K[0-9.]+" "\$MEM_OUTPUT" | tail -1 || echo "N/A")
MEM_RANGE=\$(grep -oP "variance.*\K[0-9.]+(?= MB)" "\$MEM_OUTPUT" | tail -1 || echo "N/A")
rm -f "\$MEM_OUTPUT"

echo ""
echo "=== Phase 2: Functional Tests ==="
FUNC_PASSED=0
FUNC_FAILED=0
FUNC_TOTAL=0

for test in scripts/tests/test-func-*.sh; do
    ((FUNC_TOTAL++))
    test_name=\$(basename "\$test")
    printf "[%d/7] %s\n" "\$FUNC_TOTAL" "\$test_name"
    if "\$test"; then
        printf "✓ PASS\n\n"
        ((FUNC_PASSED++))
    else
        printf "✗ FAIL\n\n"
        ((FUNC_FAILED++))
        FUNC_EXIT=1
    fi
done

# Display summary
echo ""
echo "========================================"
echo "  $SUITE_NAME SUITE SUMMARY" | tr "[:lower:]" "[:upper:]"
echo "========================================"
if [ "\$MEM_R2" != "N/A" ]; then
    printf "  Memory Tests:     %s (R²=%s, range=%s MB)\n" "\$MEM_STATUS" "\$MEM_R2" "\$MEM_RANGE"
else
    printf "  Memory Tests:     %s\n" "\$MEM_STATUS"
fi
printf "  Functional Tests: %d/%d PASS" "\$FUNC_PASSED" "\$FUNC_TOTAL"
if [ \$FUNC_FAILED -gt 0 ]; then
    printf ", %d/%d FAIL\n" "\$FUNC_FAILED" "\$FUNC_TOTAL"
else
    printf "\n"
fi
echo ""
if [ \$MEM_EXIT -eq 0 ] && [ \$FUNC_EXIT -eq 0 ]; then
    echo "  Overall Result:   PASS"
    echo "========================================"
    exit 0
else
    echo "  Overall Result:   FAIL"
    echo "========================================"
    exit 1
fi
EOF
            SSH_PID=$!
            wait $SSH_PID
            EXIT_CODE=$?
            trap - INT TERM
            exit $EXIT_CODE
        fi
        ;;
    help|--help|-h)
        show_help
        exit 0
        ;;
    *)
        printf "${COLOR_ERROR}Unknown test type: $TEST_TYPE${COLOR_RESET}\n"
        printf "Available types: mem, func, release\n"
        printf "\n"
        show_help
        exit 1
        ;;
esac

# Execute test (only for mem type now)
if [ "$RUN_LOCAL" = true ]; then
    # Local execution
    printf "${COLOR_INFO}Running tests locally...${COLOR_RESET}\n"
    printf "\n"
    exec "$TEST_SCRIPT" "$@"
else
    # VM execution (default)
    detect_vm_for_test
    
    # Build command with all args properly escaped
    CMD="cd $REMOTE_PROJECT_DIR && $TEST_SCRIPT"
    for arg in "$@"; do
        CMD="$CMD $(printf '%q' "$arg")"
    done
    
    # Execute on VM with TTY for interactive prompts and Ctrl+C handling
    printf "\n"
    printf "${COLOR_SUCCESS}Executing test on VM...${COLOR_RESET}\n"
    printf "\n"
    trap 'kill $SSH_PID 2>/dev/null; exit 130' INT TERM
    ssh -t "$VM_DOMAIN" "$CMD" &
    SSH_PID=$!
    wait $SSH_PID
    EXIT_CODE=$?
    trap - INT TERM
    exit $EXIT_CODE
fi
