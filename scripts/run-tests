#!/bin/bash
# Unified Test Runner - Handles both local and VM testing
# Usage: test <type> [--local] [args...]
#   Types: mem, func (future)
#   Default: Run in VM via SSH (most common workflow)
#   --local: Run on current machine

set -e

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source the shared VM detection library
source "$SCRIPT_DIR/lib/vm-detect.sh"

# Source test setup library for send_notification function
source "$SCRIPT_DIR/tests/lib/setup.sh"

# Color codes
COLOR_RESET='\033[0m'
COLOR_INFO='\033[36m'
COLOR_SUCCESS='\033[32m'
COLOR_ERROR='\033[31m'
COLOR_WARN='\033[33m'

# Detect VM for test execution
detect_vm_for_test() {
    # Try to use active profile first
    if vm_profile_read_active 2>/dev/null; then
        # Check if the cached VM is still running
        if vm_cache_is_valid 2>/dev/null; then
            # Active profile VM is running - use it
            printf "${COLOR_INFO}Using active profile: $VM_DOMAIN${COLOR_RESET}\n"
        else
            # Cached VM not running - need to detect
            unset VM_DOMAIN
        fi
    fi
    
    # If no valid cached VM, detect running VMs
    if [[ -z "$VM_DOMAIN" ]]; then
        local running_vms
        running_vms=$(vm_get_running)
        
        if [[ -z "$running_vms" ]]; then
            printf "${COLOR_ERROR}No VMs are currently running${COLOR_RESET}\n"
            printf "\n"
            printf "Start a VM first with: ./scripts/vm headless start\n"
            exit 1
        fi
        
        # Count running VMs
        local count
        count=$(echo "$running_vms" | wc -l)
        
        if [[ $count -eq 1 ]]; then
            VM_DOMAIN="$running_vms"
        else
            # Multiple VMs - prompt to select
            printf "${COLOR_INFO}Multiple VMs are running:${COLOR_RESET}\n"
            printf "\n"
            
            local vms=()
            local i=1
            while IFS= read -r vm; do
                [[ -z "$vm" ]] && continue
                local title=$(vm_get_title "$vm")
                printf "  %d) %s - \"%s\"\n" "$i" "$vm" "$title"
                vms+=("$vm")
                ((i++))
            done <<< "$running_vms"
            
            printf "\n"
            read -p "Select VM [1-${#vms[@]}]: " selection
            
            if [[ ! "$selection" =~ ^[0-9]+$ ]] || [[ $selection -lt 1 ]] || [[ $selection -gt ${#vms[@]} ]]; then
                printf "${COLOR_ERROR}Invalid selection${COLOR_RESET}\n"
                exit 1
            fi
            
            VM_DOMAIN="${vms[$((selection-1))]}"
        fi
    fi
    
    # Test SSH connection
    printf "${COLOR_INFO}Testing SSH connection to %s...${COLOR_RESET}\n" "$VM_DOMAIN"
    if ! ssh -o ConnectTimeout=5 -o BatchMode=yes "$VM_DOMAIN" "exit" 2>/dev/null; then
        printf "${COLOR_ERROR}Cannot connect to VM: %s${COLOR_RESET}\n" "$VM_DOMAIN"
        printf "\n"
        printf "Run './scripts/vm setup' first to configure SSH access.\n"
        exit 1
    fi
    
    # Use VM_MOUNT_PATH from profile (set by vm_profile_read_active)
    REMOTE_PROJECT_DIR="$VM_MOUNT_PATH"
    
    # Verify the mount is accessible
    if [[ -z "$REMOTE_PROJECT_DIR" ]]; then
        printf "${COLOR_ERROR}VM_MOUNT_PATH not set in profile${COLOR_RESET}\n"
        printf "\n"
        printf "Run './scripts/vm setup' to configure the VM mount.\n"
        exit 1
    fi
    
    printf "${COLOR_INFO}Verifying project files at %s...${COLOR_RESET}\n" "$REMOTE_PROJECT_DIR"
    if ! ssh "$VM_DOMAIN" "test -f '$REMOTE_PROJECT_DIR/extension/metadata.json'" 2>/dev/null; then
        printf "${COLOR_ERROR}Project files not accessible at %s${COLOR_RESET}\n" "$REMOTE_PROJECT_DIR"
        printf "\n"
        printf "Troubleshooting:\n"
        printf "  1. Run './scripts/vm setup' to reconfigure virtiofs mount\n"
        printf "  2. Ensure virtiofs is mounted: ssh %s 'mountpoint /mnt/zoned'\n" "$VM_DOMAIN"
        printf "  3. Check VM is running: virsh list\n"
        exit 1
    fi
    
    printf "${COLOR_SUCCESS}âœ“ Connected to VM: %s${COLOR_RESET}\n" "$VM_DOMAIN"
    printf "${COLOR_INFO}Project directory: %s${COLOR_RESET}\n" "$REMOTE_PROJECT_DIR"
}

show_help() {
    printf "${COLOR_INFO}Unified Test Runner${COLOR_RESET}\n"
    printf "\n"
    printf "${COLOR_SUCCESS}Usage:${COLOR_RESET} ./scripts/test <type> [--local] [args...]\n"
    printf "\n"
    printf "${COLOR_SUCCESS}Test Types:${COLOR_RESET}\n"
    printf "  ${COLOR_INFO}mem${COLOR_RESET}          - Memory leak testing with statistical analysis\n"
    printf "  ${COLOR_INFO}func${COLOR_RESET}         - Functional correctness testing\n"
    printf "  ${COLOR_INFO}release${COLOR_RESET}      - Full suite (mem deep + all functional tests)\n"
    printf "  ${COLOR_INFO}release-test${COLOR_RESET} - Quick release validation (mem 2min + func)\n"
    printf "  ${COLOR_INFO}notify${COLOR_RESET}       - Test notification system\n"
    printf "\n"
    printf "${COLOR_SUCCESS}Execution Mode:${COLOR_RESET}\n"
    printf "  ${COLOR_INFO}Default${COLOR_RESET}  - Run in VM via SSH (recommended)\n"
    printf "  ${COLOR_INFO}--local${COLOR_RESET} - Run on current machine\n"
    printf "\n"
    printf "${COLOR_SUCCESS}Examples:${COLOR_RESET}\n"
    printf "  ${COLOR_INFO}Quick verification (feature work):${COLOR_RESET}\n"
    printf "    ./scripts/test mem --preset quick    # Memory test (1-3 min, ~6 min)\n"
    printf "    ./scripts/test func                  # All functional tests\n"
    printf "    ./scripts/test release-test          # Quick release check (~5-10 min)\n"
    printf "\n"
    printf "  ${COLOR_INFO}Release preparation:${COLOR_RESET}\n"
    printf "    ./scripts/test release               # Full suite (mem deep + func)\n"
    printf "    ./scripts/test mem --preset deep     # Just memory (1-20 min)\n"
    printf "\n"
    printf "  ${COLOR_INFO}Utilities:${COLOR_RESET}\n"
    printf "    ./scripts/test notify                # Test notification system\n"
    printf "\n"
    printf "${COLOR_INFO}Note:${COLOR_RESET} Most testing happens in VM. Use --local for quick local verification.\n"
    printf "\n"
}

# Parse command
TEST_TYPE="${1:-}"
if [[ -z "$TEST_TYPE" ]]; then
    show_help
    exit 1
fi
shift

# Check for --local and --no-cleanup flags
RUN_LOCAL=false
NO_CLEANUP=false
while [[ $# -gt 0 ]]; do
    case "$1" in
        --local)
            RUN_LOCAL=true
            shift
            ;;
        --no-cleanup)
            NO_CLEANUP=true
            shift
            ;;
        *)
            break
            ;;
    esac
done


# Validate test type
case "$TEST_TYPE" in
    notify)
        # Test notification system
        printf "${COLOR_INFO}Testing notification system...${COLOR_RESET}\n"
        printf "\n"
        printf "Sending test notifications:\n"
        printf "  1. PASS notification\n"
        send_notification "PASS" "Notification Test" "PASS notification is working"
        sleep 2
        printf "  2. WARN notification\n"
        send_notification "WARN" "Notification Test" "WARN notification is working"
        sleep 2
        printf "  3. FAIL notification\n"
        send_notification "FAIL" "Notification Test" "FAIL notification is working"
        printf "\n"
        printf "${COLOR_SUCCESS}âœ“ Test notifications sent!${COLOR_RESET}\n"
        printf "\n"
        printf "If you didn't see notifications, check:\n"
        printf "  - notify-send is installed: ${COLOR_INFO}command -v notify-send${COLOR_RESET}\n"
        printf "  - Notification daemon is running (usually automatic in desktop environments)\n"
        exit 0
        ;;
    mem|memory)
        TEST_SCRIPT="./scripts/tests/test-mem-with-restarts"
        ;;
    func|functional)
        # Run all functional tests
        if [ "$RUN_LOCAL" = true ]; then
            printf "${COLOR_INFO}Running functional tests locally...${COLOR_RESET}\n"
            printf "\n"
            "$SCRIPT_DIR/tests/test-func-runner.sh" "$@"
            TEST_EXIT=$?
            
            # Send notification based on test results
            if [ $TEST_EXIT -eq 0 ]; then
                send_notification "PASS" "Functional Tests Complete" "All tests passed"
            else
                send_notification "FAIL" "Functional Tests Failed" "One or more tests failed"
            fi
            
            exit $TEST_EXIT
        else
            detect_vm_for_test
            printf "\n"
            printf "${COLOR_SUCCESS}Executing functional tests on VM...${COLOR_RESET}\n"
            printf "\n"
            # Run test runner on VM with all arguments
            # Build command with all args properly escaped
            CMD="cd $REMOTE_PROJECT_DIR && ./scripts/tests/test-func-runner.sh"
            for arg in "$@"; do
                CMD="$CMD $(printf '%q' "$arg")"
            done
            ssh -t "$VM_DOMAIN" "$CMD"
            TEST_EXIT=$?
            
            # Send notification from host based on VM test results
            if [ $TEST_EXIT -eq 0 ]; then
                send_notification "PASS" "Functional Tests Complete" "All tests passed"
            else
                send_notification "FAIL" "Functional Tests Failed" "One or more tests failed"
            fi
            
            exit $TEST_EXIT
        fi
        ;;
    release|release-test)
        # Determine preset based on test type
        if [ "$TEST_TYPE" = "release-test" ]; then
            MEM_PRESET="test"
            SUITE_NAME="release-test"
            printf "${COLOR_INFO}Running quick release validation suite...${COLOR_RESET}\n"
            printf "${COLOR_INFO}  1. Memory tests (2-minute max)${COLOR_RESET}\n"
            printf "${COLOR_INFO}  2. All functional tests${COLOR_RESET}\n"
        else
            MEM_PRESET="deep"
            SUITE_NAME="release"
            printf "${COLOR_INFO}Running full release test suite...${COLOR_RESET}\n"
            printf "${COLOR_INFO}  1. Memory tests (deep preset: 1-20 min)${COLOR_RESET}\n"
            printf "${COLOR_INFO}  2. All functional tests${COLOR_RESET}\n"
        fi
        printf "\n"
        
        # Show early confirmation if --no-cleanup is set
        if [ "$NO_CLEANUP" = "true" ]; then
            printf "${COLOR_INFO}ðŸ“Œ Data will not be cleaned up after tests${COLOR_RESET}\n"
            printf "\n"
        fi
        
        if [ "$RUN_LOCAL" = true ]; then
            # Local execution
            MEM_EXIT=0
            FUNC_EXIT=0
            MEM_OUTPUT=$(mktemp)
            FUNC_OUTPUT=$(mktemp)
            MEM_JSON=$(mktemp --suffix=.json)
            FUNC_JSON=$(mktemp --suffix=.json)
            
            printf "${COLOR_INFO}=== Phase 1: Memory Tests ===${COLOR_RESET}\n"
            if JSON_OUTPUT="$MEM_JSON" ./scripts/tests/test-mem-with-restarts --preset "$MEM_PRESET" 2>&1 | tee "$MEM_OUTPUT"; then
                MEM_STATUS="PASS"
                MEM_EXIT=0
            else
                MEM_EXIT=$?
                if grep -q "WARN:" "$MEM_OUTPUT"; then
                    MEM_STATUS="WARN"
                else
                    MEM_STATUS="FAIL"
                fi
            fi
            
            printf "\n"
            printf "${COLOR_INFO}=== Phase 2: Functional Tests ===${COLOR_RESET}\n"
            
            # Run functional test runner with JSON output
            if JSON_OUTPUT="$FUNC_JSON" "$SCRIPT_DIR/tests/test-func-runner.sh" 2>&1 | tee "$FUNC_OUTPUT"; then
                FUNC_EXIT=0
            else
                FUNC_EXIT=1
            fi
            
            # Use JSON-based formatter with named parameters
            "$SCRIPT_DIR/tests/lib/format-release-summary-json.sh" --mem "$MEM_JSON" --func "$FUNC_JSON" --suite "$SUITE_NAME"
            SUMMARY_EXIT=$?
            
            # Send notification based on test results
            if [ $SUMMARY_EXIT -eq 0 ]; then
                send_notification "PASS" "$(echo $SUITE_NAME | sed 's/-/ /g' | sed 's/\b\(.\)/\u\1/g') Complete" "All tests passed"
            else
                send_notification "FAIL" "$(echo $SUITE_NAME | sed 's/-/ /g' | sed 's/\b\(.\)/\u\1/g') Failed" "One or more tests failed"
            fi
            
            # Clean up temp files (unless --no-cleanup)
            if [ "$NO_CLEANUP" != "true" ]; then
                rm -f "$MEM_OUTPUT" "$FUNC_OUTPUT" "$MEM_JSON" "$FUNC_JSON"
            else
                printf "\n"
                printf "${COLOR_INFO}Test outputs saved:${COLOR_RESET}\n"
                printf "  Memory (text): %s\n" "$MEM_OUTPUT"
                printf "  Memory (JSON): %s\n" "$MEM_JSON"
                printf "  Func (text):   %s\n" "$FUNC_OUTPUT"
                printf "  Func (JSON):   %s\n" "$FUNC_JSON"
            fi
            
            exit $SUMMARY_EXIT
        else
            # VM execution with enhanced summary
            detect_vm_for_test
            printf "\n"
            printf "${COLOR_SUCCESS}Executing $SUITE_NAME suite on VM...${COLOR_RESET}\n"
            printf "\n"
            
            # Capture SSH output to parse file paths
            SSH_OUTPUT=$(mktemp)
            ssh -t "$VM_DOMAIN" << EOSSH 2>&1 | tee "$SSH_OUTPUT"
cd $REMOTE_PROJECT_DIR

# Set NO_CLEANUP from host
NO_CLEANUP=$NO_CLEANUP

MEM_EXIT=0
FUNC_EXIT=0
MEM_OUTPUT=\$(mktemp)
FUNC_OUTPUT=\$(mktemp)
MEM_JSON=\$(mktemp --suffix=.json)
FUNC_JSON=\$(mktemp --suffix=.json)

echo "=== Phase 1: Memory Tests ==="
JSON_OUTPUT="\$MEM_JSON" ./scripts/tests/test-mem-with-restarts --preset $MEM_PRESET 2>&1 | tee "\$MEM_OUTPUT"
MEM_EXIT=\${PIPESTATUS[0]}

echo ""
echo "=== Phase 2: Functional Tests ==="

# Run functional test runner with JSON output
JSON_OUTPUT="\$FUNC_JSON" ./scripts/tests/test-func-runner.sh 2>&1 | tee "\$FUNC_OUTPUT"
FUNC_EXIT=\${PIPESTATUS[0]}

# Use JSON-based formatter with named parameters
./scripts/tests/lib/format-release-summary-json.sh --mem "\$MEM_JSON" --func "\$FUNC_JSON" --suite "$SUITE_NAME"
SUMMARY_EXIT=\$?

# Clean up or save files
if [ "\$NO_CLEANUP" != "true" ]; then
    rm -f "\$MEM_OUTPUT" "\$FUNC_OUTPUT" "\$MEM_JSON" "\$FUNC_JSON"
else
    echo ""
    echo "Test outputs saved on VM:"
    echo "  Memory (text): \$MEM_OUTPUT"
    echo "  Memory (JSON): \$MEM_JSON"
    echo "  Func (text):   \$FUNC_OUTPUT"
    echo "  Func (JSON):   \$FUNC_JSON"
    echo "##FILE_PATHS##\$MEM_OUTPUT|\$FUNC_OUTPUT|\$MEM_JSON|\$FUNC_JSON"
fi

exit \$SUMMARY_EXIT
EOSSH
            SSH_EXIT=$?
            
            # Send notification from host based on VM test results
            if [ $SSH_EXIT -eq 0 ]; then
                send_notification "PASS" "$(echo $SUITE_NAME | sed 's/-/ /g' | sed 's/\b\(.\)/\u\1/g') Complete" "All tests passed"
            else
                send_notification "FAIL" "$(echo $SUITE_NAME | sed 's/-/ /g' | sed 's/\b\(.\)/\u\1/g') Failed" "One or more tests failed"
            fi
            
            # If --no-cleanup was used, parse file paths and copy to local machine
            if [ "$NO_CLEANUP" = "true" ]; then
                FILE_PATHS=$(grep "^##FILE_PATHS##" "$SSH_OUTPUT" | sed 's/^##FILE_PATHS##//' || echo "")
                
                if [ -n "$FILE_PATHS" ]; then
                    VM_MEM_TXT=$(echo "$FILE_PATHS" | cut -d'|' -f1)
                    VM_FUNC_TXT=$(echo "$FILE_PATHS" | cut -d'|' -f2)
                    VM_MEM_JSON=$(echo "$FILE_PATHS" | cut -d'|' -f3)
                    VM_FUNC_JSON=$(echo "$FILE_PATHS" | cut -d'|' -f4)
                    
                    printf "\n"
                    printf "${COLOR_INFO}Copying test outputs to local machine...${COLOR_RESET}\n"
                    
                    # Copy all files from VM to local machine
                    if scp "$VM_DOMAIN:$VM_MEM_TXT" /tmp/mem-output.txt 2>/dev/null && \
                       scp "$VM_DOMAIN:$VM_FUNC_TXT" /tmp/func-output.txt 2>/dev/null && \
                       scp "$VM_DOMAIN:$VM_MEM_JSON" /tmp/mem-results.json 2>/dev/null && \
                       scp "$VM_DOMAIN:$VM_FUNC_JSON" /tmp/func-results.json 2>/dev/null; then
                        printf "\n"
                        printf "${COLOR_SUCCESS}Files copied to local machine:${COLOR_RESET}\n"
                        printf "  Memory (text): /tmp/mem-output.txt\n"
                        printf "  Memory (JSON): /tmp/mem-results.json\n"
                        printf "  Func (text):   /tmp/func-output.txt\n"
                        printf "  Func (JSON):   /tmp/func-results.json\n"
                        printf "\n"
                        printf "${COLOR_INFO}You can reformat with:${COLOR_RESET}\n"
                        printf "  ./scripts/tests/lib/format-release-summary-json.sh --mem /tmp/mem-results.json --func /tmp/func-results.json --suite $SUITE_NAME\n"
                    else
                        printf "${COLOR_WARN}Warning: Could not copy files from VM${COLOR_RESET}\n"
                    fi
                fi
            fi
            
            # Clean up temp file
            rm -f "$SSH_OUTPUT"
            
            exit $SSH_EXIT
        fi
        ;;
    help|--help|-h)
        show_help
        exit 0
        ;;
    *)
        printf "${COLOR_ERROR}Unknown test type: $TEST_TYPE${COLOR_RESET}\n"
        printf "Available types: mem, func, release\n"
        printf "\n"
        show_help
        exit 1
        ;;
esac

# Execute test (only for mem type now)
if [ "$RUN_LOCAL" = true ]; then
    # Local execution
    printf "${COLOR_INFO}Running tests locally...${COLOR_RESET}\n"
    printf "\n"
    "$TEST_SCRIPT" "$@"
    TEST_EXIT=$?
    
    # Send notification based on test results
    if [ $TEST_EXIT -eq 0 ]; then
        send_notification "PASS" "Memory Test Complete" "Test passed"
    else
        send_notification "FAIL" "Memory Test Failed" "Test failed with exit code $TEST_EXIT"
    fi
    
    exit $TEST_EXIT
else
    # VM execution (default)
    detect_vm_for_test
    
    # Build command with all args properly escaped
    CMD="cd $REMOTE_PROJECT_DIR && $TEST_SCRIPT"
    for arg in "$@"; do
        CMD="$CMD $(printf '%q' "$arg")"
    done
    
    # Execute on VM with TTY for interactive prompts
    printf "\n"
    printf "${COLOR_SUCCESS}Executing test on VM...${COLOR_RESET}\n"
    printf "\n"
    ssh -t "$VM_DOMAIN" "$CMD"
    TEST_EXIT=$?
    
    # Send notification from host based on VM test results
    if [ $TEST_EXIT -eq 0 ]; then
        send_notification "PASS" "Memory Test Complete" "Test passed"
    else
        send_notification "FAIL" "Memory Test Failed" "Test failed with exit code $TEST_EXIT"
    fi
    
    exit $TEST_EXIT
fi
