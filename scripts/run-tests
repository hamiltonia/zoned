#!/bin/bash
# Unified Test Runner - Handles both local and VM testing
# Usage: test <type> [--local] [args...]
#   Types: mem, func (future)
#   Default: Run in VM via SSH (most common workflow)
#   --local: Run on current machine

set -e

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source the shared VM detection library
source "$SCRIPT_DIR/lib/vm-detect.sh"

# Color codes
COLOR_RESET='\033[0m'
COLOR_INFO='\033[36m'
COLOR_SUCCESS='\033[32m'
COLOR_ERROR='\033[31m'
COLOR_WARN='\033[33m'

# Detect VM for test execution
detect_vm_for_test() {
    # Try to use active profile first
    if vm_profile_read_active 2>/dev/null; then
        # Check if the cached VM is still running
        if vm_cache_is_valid 2>/dev/null; then
            # Active profile VM is running - use it
            printf "${COLOR_INFO}Using active profile: $VM_DOMAIN${COLOR_RESET}\n"
        else
            # Cached VM not running - need to detect
            unset VM_DOMAIN
        fi
    fi
    
    # If no valid cached VM, detect running VMs
    if [[ -z "$VM_DOMAIN" ]]; then
        local running_vms
        running_vms=$(vm_get_running)
        
        if [[ -z "$running_vms" ]]; then
            printf "${COLOR_ERROR}No VMs are currently running${COLOR_RESET}\n"
            printf "\n"
            printf "Start a VM first with: ./scripts/vm headless start\n"
            exit 1
        fi
        
        # Count running VMs
        local count
        count=$(echo "$running_vms" | wc -l)
        
        if [[ $count -eq 1 ]]; then
            VM_DOMAIN="$running_vms"
        else
            # Multiple VMs - prompt to select
            printf "${COLOR_INFO}Multiple VMs are running:${COLOR_RESET}\n"
            printf "\n"
            
            local vms=()
            local i=1
            while IFS= read -r vm; do
                [[ -z "$vm" ]] && continue
                local title=$(vm_get_title "$vm")
                printf "  %d) %s - \"%s\"\n" "$i" "$vm" "$title"
                vms+=("$vm")
                ((i++))
            done <<< "$running_vms"
            
            printf "\n"
            read -p "Select VM [1-${#vms[@]}]: " selection
            
            if [[ ! "$selection" =~ ^[0-9]+$ ]] || [[ $selection -lt 1 ]] || [[ $selection -gt ${#vms[@]} ]]; then
                printf "${COLOR_ERROR}Invalid selection${COLOR_RESET}\n"
                exit 1
            fi
            
            VM_DOMAIN="${vms[$((selection-1))]}"
        fi
    fi
    
    # Test SSH connection
    printf "${COLOR_INFO}Testing SSH connection to %s...${COLOR_RESET}\n" "$VM_DOMAIN"
    if ! ssh -o ConnectTimeout=5 -o BatchMode=yes "$VM_DOMAIN" "exit" 2>/dev/null; then
        printf "${COLOR_ERROR}Cannot connect to VM: %s${COLOR_RESET}\n" "$VM_DOMAIN"
        printf "\n"
        printf "Run './scripts/vm setup' first to configure SSH access.\n"
        exit 1
    fi
    
    # Use VM_MOUNT_PATH from profile (set by vm_profile_read_active)
    REMOTE_PROJECT_DIR="$VM_MOUNT_PATH"
    
    # Verify the mount is accessible
    if [[ -z "$REMOTE_PROJECT_DIR" ]]; then
        printf "${COLOR_ERROR}VM_MOUNT_PATH not set in profile${COLOR_RESET}\n"
        printf "\n"
        printf "Run './scripts/vm setup' to configure the VM mount.\n"
        exit 1
    fi
    
    printf "${COLOR_INFO}Verifying project files at %s...${COLOR_RESET}\n" "$REMOTE_PROJECT_DIR"
    if ! ssh "$VM_DOMAIN" "test -f '$REMOTE_PROJECT_DIR/extension/metadata.json'" 2>/dev/null; then
        printf "${COLOR_ERROR}Project files not accessible at %s${COLOR_RESET}\n" "$REMOTE_PROJECT_DIR"
        printf "\n"
        printf "Troubleshooting:\n"
        printf "  1. Run './scripts/vm setup' to reconfigure virtiofs mount\n"
        printf "  2. Ensure virtiofs is mounted: ssh %s 'mountpoint /mnt/zoned'\n" "$VM_DOMAIN"
        printf "  3. Check VM is running: virsh list\n"
        exit 1
    fi
    
    printf "${COLOR_SUCCESS}✓ Connected to VM: %s${COLOR_RESET}\n" "$VM_DOMAIN"
    printf "${COLOR_INFO}Project directory: %s${COLOR_RESET}\n" "$REMOTE_PROJECT_DIR"
}

show_help() {
    printf "${COLOR_INFO}Unified Test Runner${COLOR_RESET}\n"
    printf "\n"
    printf "${COLOR_SUCCESS}Usage:${COLOR_RESET} ./scripts/test <type> [--local] [args...]\n"
    printf "\n"
    printf "${COLOR_SUCCESS}Test Types:${COLOR_RESET}\n"
    printf "  ${COLOR_INFO}mem${COLOR_RESET}          - Memory leak testing with statistical analysis\n"
    printf "  ${COLOR_INFO}func${COLOR_RESET}         - Functional correctness testing\n"
    printf "  ${COLOR_INFO}release${COLOR_RESET}      - Full suite (mem deep + all functional tests)\n"
    printf "  ${COLOR_INFO}release-test${COLOR_RESET} - Quick release validation (mem 2min + func)\n"
    printf "\n"
    printf "${COLOR_SUCCESS}Execution Mode:${COLOR_RESET}\n"
    printf "  ${COLOR_INFO}Default${COLOR_RESET}  - Run in VM via SSH (recommended)\n"
    printf "  ${COLOR_INFO}--local${COLOR_RESET} - Run on current machine\n"
    printf "\n"
    printf "${COLOR_SUCCESS}Examples:${COLOR_RESET}\n"
    printf "  ${COLOR_INFO}Quick verification (feature work):${COLOR_RESET}\n"
    printf "    ./scripts/test mem --preset quick    # Memory test (1-3 min, ~6 min)\n"
    printf "    ./scripts/test func                  # All functional tests\n"
    printf "    ./scripts/test release-test          # Quick release check (~5-10 min)\n"
    printf "\n"
    printf "  ${COLOR_INFO}Release preparation:${COLOR_RESET}\n"
    printf "    ./scripts/test release               # Full suite (mem deep + func)\n"
    printf "    ./scripts/test mem --preset deep     # Just memory (1-20 min)\n"
    printf "\n"
    printf "${COLOR_INFO}Note:${COLOR_RESET} Most testing happens in VM. Use --local for quick local verification.\n"
    printf "\n"
}

# Parse command
TEST_TYPE="${1:-}"
if [[ -z "$TEST_TYPE" ]]; then
    show_help
    exit 1
fi
shift

# Check for --local flag
RUN_LOCAL=false
if [[ "$1" == "--local" ]]; then
    RUN_LOCAL=true
    shift
fi

# Validate test type
case "$TEST_TYPE" in
    mem|memory)
        TEST_SCRIPT="./scripts/tests/test-mem-with-restarts"
        ;;
    func|functional)
        # Run all functional tests
        if [ "$RUN_LOCAL" = true ]; then
            printf "${COLOR_INFO}Running functional tests locally...${COLOR_RESET}\n"
            printf "\n"
            exec "$SCRIPT_DIR/tests/test-func-runner.sh" "$@"
        else
            detect_vm_for_test
            printf "\n"
            printf "${COLOR_SUCCESS}Executing functional tests on VM...${COLOR_RESET}\n"
            printf "\n"
            # Run test runner on VM with all arguments
            # Build command with all args properly escaped
            CMD="cd $REMOTE_PROJECT_DIR && ./scripts/tests/test-func-runner.sh"
            for arg in "$@"; do
                CMD="$CMD $(printf '%q' "$arg")"
            done
            ssh -t "$VM_DOMAIN" "$CMD"
            exit $?
        fi
        ;;
    release|release-test)
        # Determine preset based on test type
        if [ "$TEST_TYPE" = "release-test" ]; then
            MEM_PRESET="test"
            SUITE_NAME="release-test"
            printf "${COLOR_INFO}Running quick release validation suite...${COLOR_RESET}\n"
            printf "${COLOR_INFO}  1. Memory tests (2-minute max)${COLOR_RESET}\n"
            printf "${COLOR_INFO}  2. All functional tests${COLOR_RESET}\n"
        else
            MEM_PRESET="deep"
            SUITE_NAME="release"
            printf "${COLOR_INFO}Running full release test suite...${COLOR_RESET}\n"
            printf "${COLOR_INFO}  1. Memory tests (deep preset: 1-20 min)${COLOR_RESET}\n"
            printf "${COLOR_INFO}  2. All functional tests${COLOR_RESET}\n"
        fi
        printf "\n"
        
        if [ "$RUN_LOCAL" = true ]; then
            # Local execution
            MEM_EXIT=0
            FUNC_EXIT=0
            MEM_OUTPUT=$(mktemp)
            
            printf "${COLOR_INFO}=== Phase 1: Memory Tests ===${COLOR_RESET}\n"
            if ./scripts/tests/test-mem-with-restarts --preset "$MEM_PRESET" 2>&1 | tee "$MEM_OUTPUT"; then
                MEM_STATUS="PASS"
            else
                MEM_STATUS="FAIL"
                MEM_EXIT=1
            fi
            
            # Extract memory test summary info
            MEM_R2=$(grep -oP 'R²=\K[0-9.]+' "$MEM_OUTPUT" | tail -1 || echo "N/A")
            MEM_RANGE=$(grep -oP 'variance.*\K[0-9.]+(?= MB)' "$MEM_OUTPUT" | tail -1 || echo "N/A")
            rm -f "$MEM_OUTPUT"
            
            printf "\n"
            printf "${COLOR_INFO}=== Phase 2: Functional Tests ===${COLOR_RESET}\n"
            
            # Run functional test runner and capture output
            FUNC_OUTPUT=$(mktemp)
            if "$SCRIPT_DIR/tests/test-func-runner.sh" 2>&1 | tee "$FUNC_OUTPUT"; then
                FUNC_EXIT=0
            else
                FUNC_EXIT=1
            fi
            
            # Parse results from runner output
            FUNC_PASSED=$(grep -oP '(\d+) of \d+ tests (passed|failed)' "$FUNC_OUTPUT" | head -1 | grep -oP '^\d+' || echo "0")
            FUNC_FAILED=$(grep -oP '\d+ of (\d+) tests failed' "$FUNC_OUTPUT" | grep -oP '\d+ of \K\d+' || echo "0")
            FUNC_TOTAL=$((FUNC_PASSED + FUNC_FAILED))
            
            # If parsing failed, get total from "All X tests passed"
            if [ "$FUNC_TOTAL" -eq 0 ]; then
                FUNC_TOTAL=$(grep -oP 'All \K\d+(?= tests passed)' "$FUNC_OUTPUT" || echo "7")
                FUNC_PASSED=$FUNC_TOTAL
                FUNC_FAILED=0
            fi
            
            rm -f "$FUNC_OUTPUT"
            
            # Display summary
            printf "\n"
            printf "========================================\n"
            printf "  %s SUITE SUMMARY\n" "$(echo $SUITE_NAME | tr '[:lower:]' '[:upper:]')"
            printf "========================================\n"
            if [ "$MEM_R2" != "N/A" ]; then
                printf "  Memory Tests:     %s (R²=%s, range=%s MB)\n" "$MEM_STATUS" "$MEM_R2" "$MEM_RANGE"
            else
                printf "  Memory Tests:     %s\n" "$MEM_STATUS"
            fi
            printf "  Functional Tests: %d/%d PASS" "$FUNC_PASSED" "$FUNC_TOTAL"
            if [ $FUNC_FAILED -gt 0 ]; then
                printf ", %d/%d FAIL\n" "$FUNC_FAILED" "$FUNC_TOTAL"
            else
                printf "\n"
            fi
            printf "\n"
            if [ $MEM_EXIT -eq 0 ] && [ $FUNC_EXIT -eq 0 ]; then
                printf "  Overall Result:   ${COLOR_SUCCESS}PASS${COLOR_RESET}\n"
                printf "========================================\n"
                exit 0
            else
                printf "  Overall Result:   ${COLOR_ERROR}FAIL${COLOR_RESET}\n"
                printf "========================================\n"
                exit 1
            fi
        else
            # VM execution with summary
            detect_vm_for_test
            printf "\n"
            printf "${COLOR_SUCCESS}Executing $SUITE_NAME suite on VM...${COLOR_RESET}\n"
            printf "\n"
            
            ssh -t "$VM_DOMAIN" << EOF
cd $REMOTE_PROJECT_DIR
MEM_EXIT=0
FUNC_EXIT=0
MEM_OUTPUT=\$(mktemp)

echo "=== Phase 1: Memory Tests ==="
if ./scripts/tests/test-mem-with-restarts --preset "$MEM_PRESET" 2>&1 | tee "\$MEM_OUTPUT"; then
    MEM_STATUS="PASS"
else
    MEM_STATUS="FAIL"
    MEM_EXIT=1
fi

# Extract memory test summary
MEM_R2=\$(grep -oP "R²=\K[0-9.]+" "\$MEM_OUTPUT" | tail -1 || echo "N/A")
MEM_RANGE=\$(grep -oP "variance.*\K[0-9.]+(?= MB)" "\$MEM_OUTPUT" | tail -1 || echo "N/A")
rm -f "\$MEM_OUTPUT"

echo ""
echo "=== Phase 2: Functional Tests ==="

# Run functional test runner and capture output
FUNC_OUTPUT=\$(mktemp)
if ./scripts/tests/test-func-runner.sh 2>&1 | tee "\$FUNC_OUTPUT"; then
    FUNC_EXIT=0
else
    FUNC_EXIT=1
fi

# Parse results from runner output
FUNC_PASSED=\$(grep -oP '(\d+) of \d+ tests (passed|failed)' "\$FUNC_OUTPUT" | head -1 | grep -oP '^\d+' || echo "0")
FUNC_FAILED=\$(grep -oP '\d+ of (\d+) tests failed' "\$FUNC_OUTPUT" | grep -oP '\d+ of \K\d+' || echo "0")
FUNC_TOTAL=\$((FUNC_PASSED + FUNC_FAILED))

# If parsing failed, get total from "All X tests passed"
if [ "\$FUNC_TOTAL" -eq 0 ]; then
    FUNC_TOTAL=\$(grep -oP 'All \K\d+(?= tests passed)' "\$FUNC_OUTPUT" || echo "7")
    FUNC_PASSED=\$FUNC_TOTAL
    FUNC_FAILED=0
fi

rm -f "\$FUNC_OUTPUT"

# Display summary
echo ""
echo "========================================"
echo "  $SUITE_NAME SUITE SUMMARY" | tr "[:lower:]" "[:upper:]"
echo "========================================"
if [ "\$MEM_R2" != "N/A" ]; then
    printf "  Memory Tests:     %s (R²=%s, range=%s MB)\n" "\$MEM_STATUS" "\$MEM_R2" "\$MEM_RANGE"
else
    printf "  Memory Tests:     %s\n" "\$MEM_STATUS"
fi
printf "  Functional Tests: %d/%d PASS" "\$FUNC_PASSED" "\$FUNC_TOTAL"
if [ \$FUNC_FAILED -gt 0 ]; then
    printf ", %d/%d FAIL\n" "\$FUNC_FAILED" "\$FUNC_TOTAL"
else
    printf "\n"
fi
echo ""
if [ \$MEM_EXIT -eq 0 ] && [ \$FUNC_EXIT -eq 0 ]; then
    echo "  Overall Result:   PASS"
    echo "========================================"
    exit 0
else
    echo "  Overall Result:   FAIL"
    echo "========================================"
    exit 1
fi
EOF
            exit $?
        fi
        ;;
    help|--help|-h)
        show_help
        exit 0
        ;;
    *)
        printf "${COLOR_ERROR}Unknown test type: $TEST_TYPE${COLOR_RESET}\n"
        printf "Available types: mem, func, release\n"
        printf "\n"
        show_help
        exit 1
        ;;
esac

# Execute test (only for mem type now)
if [ "$RUN_LOCAL" = true ]; then
    # Local execution
    printf "${COLOR_INFO}Running tests locally...${COLOR_RESET}\n"
    printf "\n"
    exec "$TEST_SCRIPT" "$@"
else
    # VM execution (default)
    detect_vm_for_test
    
    # Build command with all args properly escaped
    CMD="cd $REMOTE_PROJECT_DIR && $TEST_SCRIPT"
    for arg in "$@"; do
        CMD="$CMD $(printf '%q' "$arg")"
    done
    
    # Execute on VM with TTY for interactive prompts
    printf "\n"
    printf "${COLOR_SUCCESS}Executing test on VM...${COLOR_RESET}\n"
    printf "\n"
    ssh -t "$VM_DOMAIN" "$CMD"
fi
