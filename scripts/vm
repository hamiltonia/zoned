#!/bin/bash
# VM Management Dispatcher - Main entry point for all VM operations
# Usage: vm <command> [args...]

set -e

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source the shared VM detection library
source "$SCRIPT_DIR/lib/vm-detect.sh"

# Color codes
COLOR_RESET='\033[0m'
COLOR_INFO='\033[36m'
COLOR_SUCCESS='\033[32m'
COLOR_ERROR='\033[31m'
COLOR_WARN='\033[33m'

# Detect VM for test execution
detect_vm_for_test() {
    # Try to use active profile first
    if vm_profile_read_active 2>/dev/null; then
        # Check if the cached VM is still running
        if vm_cache_is_valid 2>/dev/null; then
            # Active profile VM is running - use it
            printf "${COLOR_INFO}Using active profile: $VM_DOMAIN${COLOR_RESET}\n"
        else
            # Cached VM not running - need to detect
            unset VM_DOMAIN
        fi
    fi
    
    # If no valid cached VM, detect running VMs
    if [[ -z "$VM_DOMAIN" ]]; then
        local running_vms
        running_vms=$(vm_get_running)
        
        if [[ -z "$running_vms" ]]; then
            printf "${COLOR_ERROR}No VMs are currently running${COLOR_RESET}\n"
            printf "\n"
            printf "Start a VM first with: vm headless start\n"
            exit 1
        fi
        
        # Count running VMs
        local count
        count=$(echo "$running_vms" | wc -l)
        
        if [[ $count -eq 1 ]]; then
            VM_DOMAIN="$running_vms"
        else
            # Multiple VMs - prompt to select
            printf "${COLOR_INFO}Multiple VMs are running:${COLOR_RESET}\n"
            printf "\n"
            
            local vms=()
            local i=1
            while IFS= read -r vm; do
                [[ -z "$vm" ]] && continue
                local title=$(vm_get_title "$vm")
                printf "  %d) %s - \"%s\"\n" "$i" "$vm" "$title"
                vms+=("$vm")
                ((i++))
            done <<< "$running_vms"
            
            printf "\n"
            read -p "Select VM [1-${#vms[@]}]: " selection
            
            if [[ ! "$selection" =~ ^[0-9]+$ ]] || [[ $selection -lt 1 ]] || [[ $selection -gt ${#vms[@]} ]]; then
                printf "${COLOR_ERROR}Invalid selection${COLOR_RESET}\n"
                exit 1
            fi
            
            VM_DOMAIN="${vms[$((selection-1))]}"
        fi
    fi
    
    # Test SSH connection
    printf "${COLOR_INFO}Testing SSH connection to %s...${COLOR_RESET}\n" "$VM_DOMAIN"
    if ! ssh -o ConnectTimeout=5 -o BatchMode=yes "$VM_DOMAIN" "exit" 2>/dev/null; then
        printf "${COLOR_ERROR}Cannot connect to VM: %s${COLOR_RESET}\n" "$VM_DOMAIN"
        printf "\n"
        printf "Run 'vm setup' first to configure SSH access.\n"
        exit 1
    fi
    
    # Use VM_MOUNT_PATH from profile (set by vm_profile_read_active)
    REMOTE_PROJECT_DIR="$VM_MOUNT_PATH"
    
    # Verify the mount is accessible
    if [[ -z "$REMOTE_PROJECT_DIR" ]]; then
        printf "${COLOR_ERROR}VM_MOUNT_PATH not set in profile${COLOR_RESET}\n"
        printf "\n"
        printf "Run 'vm setup' to configure the VM mount.\n"
        exit 1
    fi
    
    printf "${COLOR_INFO}Verifying project files at %s...${COLOR_RESET}\n" "$REMOTE_PROJECT_DIR"
    if ! ssh "$VM_DOMAIN" "test -f '$REMOTE_PROJECT_DIR/extension/metadata.json'" 2>/dev/null; then
        printf "${COLOR_ERROR}Project files not accessible at %s${COLOR_RESET}\n" "$REMOTE_PROJECT_DIR"
        printf "\n"
        printf "Troubleshooting:\n"
        printf "  1. Run 'vm setup' to reconfigure virtiofs mount\n"
        printf "  2. Ensure virtiofs is mounted: ssh %s 'mountpoint /mnt/zoned'\n" "$VM_DOMAIN"
        printf "  3. Check VM is running: virsh list\n"
        exit 1
    fi
    
    printf "${COLOR_SUCCESS}âœ“ Connected to VM: %s${COLOR_RESET}\n" "$VM_DOMAIN"
    printf "${COLOR_INFO}Project directory: %s${COLOR_RESET}\n" "$REMOTE_PROJECT_DIR"
}

show_help() {
    printf "${COLOR_INFO}VM Management Commands${COLOR_RESET}\n"
    printf "\n"
    printf "${COLOR_SUCCESS}Usage:${COLOR_RESET} vm <command> [args...]\n"
    printf "\n"
    printf "${COLOR_SUCCESS}Setup & Configuration:${COLOR_RESET}\n"
    printf "  ${COLOR_INFO}setup${COLOR_RESET} [options]     - Initial VM setup and configuration\n"
    printf "  ${COLOR_INFO}profile${COLOR_RESET} <action>    - Manage VM profiles (list, switch, info, delete)\n"
    printf "\n"
    printf "${COLOR_SUCCESS}Development:${COLOR_RESET}\n"
    printf "  ${COLOR_INFO}dev${COLOR_RESET}               - Deploy extension to VM (lint + compile + reload)\n"
    printf "  ${COLOR_INFO}logs${COLOR_RESET}              - Watch extension logs from VM\n"
    printf "\n"
    printf "${COLOR_SUCCESS}VM Control:${COLOR_RESET}\n"
    printf "  ${COLOR_INFO}headless${COLOR_RESET} <action>  - Headless mode operations (start, stop, status, display)\n"
    printf "  ${COLOR_INFO}start${COLOR_RESET} [vmname]     - Start VM with display\n"
    printf "\n"
    printf "${COLOR_SUCCESS}Testing:${COLOR_RESET}\n"
    printf "  ${COLOR_INFO}test${COLOR_RESET} func [preset] - Run functional tests (full, quick, minimal)\n"
    printf "  ${COLOR_INFO}test${COLOR_RESET} mem [preset]  - Run memory tests (standard, quick, deep)\n"
    printf "\n"
    printf "${COLOR_SUCCESS}Utilities:${COLOR_RESET}\n"
    printf "  ${COLOR_INFO}network${COLOR_RESET}           - Configure host networking\n"
    printf "  ${COLOR_INFO}virtiofs${COLOR_RESET}          - Migrate VM to virtiofs\n"
    printf "\n"
    printf "${COLOR_SUCCESS}Examples:${COLOR_RESET}\n"
    printf "  vm setup              - Run initial VM setup\n"
    printf "  vm profile list       - List all VM profiles\n"
    printf "  vm logs               - Watch VM logs\n"
    printf "  vm test func quick    - Run quick functional tests\n"
    printf "\n"
    printf "${COLOR_INFO}Tip:${COLOR_RESET} Use 'direnv' or add an alias in .zshrc:\n"
    printf "  alias vm='./scripts/vm'\n"
    printf "\n"
}

# Parse command
COMMAND="${1:-}"
shift 2>/dev/null || true

case "$COMMAND" in
    # Setup & Configuration
    setup)
        exec "$SCRIPT_DIR/user/vm-setup" "$@"
        ;;
    
    profile)
        exec "$SCRIPT_DIR/user/vm-profile" "$@"
        ;;
    
    # Install dev build
    install)
        exec "$SCRIPT_DIR/user/vm-install" "$@"
        ;;
    
    logs)
        exec "$SCRIPT_DIR/user/vm-logs" "$@"
        ;;
    
    # VM Control
    headless)
        exec "$SCRIPT_DIR/user/vm-headless" "$@"
        ;;
    
    start)
        # This would need to be implemented or use headless start
        printf "${COLOR_WARN}Use 'vm headless start' or run via Make: make vm-start${COLOR_RESET}\n"
        exit 1
        ;;
    
    # Testing
    test)
        TEST_TYPE="${1:-}"
        shift 2>/dev/null || true
        
        # Detect VM and establish connection
        detect_vm_for_test
        
        # Determine test script path
        TEST_SCRIPT=""
        case "$TEST_TYPE" in
            func|functional)
                TEST_SCRIPT="./scripts/vm-test/vm-test-func"
                ;;
            mem|memory)
                TEST_SCRIPT="./scripts/vm-test/vm-test-mem"
                ;;
            *)
                printf "${COLOR_ERROR}Unknown test type: $TEST_TYPE${COLOR_RESET}\n"
                printf "Available: func, mem\n"
                exit 1
                ;;
        esac
        
        # Build command with all args properly escaped
        CMD="cd $REMOTE_PROJECT_DIR && $TEST_SCRIPT"
        for arg in "$@"; do
            CMD="$CMD $(printf '%q' "$arg")"
        done
        
        # Execute on VM with TTY for interactive prompts
        printf "\n"
        printf "${COLOR_SUCCESS}Executing test on VM...${COLOR_RESET}\n"
        printf "\n"
        ssh -t "$VM_DOMAIN" "$CMD"
        ;;
    
    # Utilities
    network)
        exec "$SCRIPT_DIR/util/vm-network-setup" "$@"
        ;;
    
    virtiofs)
        exec "$SCRIPT_DIR/util/vm-virtiofs-migrate" "$@"
        ;;
    
    # Help
    help|--help|-h|"")
        show_help
        exit 0
        ;;
    
    # Unknown command
    *)
        printf "${COLOR_ERROR}Unknown command: $COMMAND${COLOR_RESET}\n\n"
        show_help
        exit 1
        ;;
esac
